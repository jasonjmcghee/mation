<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bouncy GSAP Animation with Morph Effect</title>
  <script type="module" src="../mation.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.13.0/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.13.0/MorphSVGPlugin.min.js"></script>
</head>
<body>
<div id="preview"></div>
<div id="svgs" style="display: none">
  <!-- SVG Shapes for Morphing -->
  <svg id="morphShapes" width="0" height="0">
    <path id="shape1" d="M20,20 C20,20 80,20 80,20 C80,20 80,80 80,80 C80,80 20,80 20,80 Z" />
    <path id="shape2" d="M50,10 C70,10 90,30 90,50 C90,70 70,90 50,90 C30,90 10,70 10,50 C10,30 30,10 50,10 Z" />
    <path id="shape3" d="M20,50 L50,20 L80,50 L50,80 Z" />
  </svg>
</div>

<script type="module">
  import { Mation, Scene, createPipeline, Easing, Layer } from '../mation.js';

  export class BouncyScene extends Scene {
    setupLayers() {
      // Create a pipeline for the main animation
      const mainPipeline = createPipeline(this.canvas);
      
      // Setup the distance field generation
      const { render: dfRender, renderTargets: dfRenderTargets } = mainPipeline.add({
        uniforms: {
          resolution: [this.width, this.height],
          inputTexture: null,
        },
        fragmentShader: `
        uniform sampler2D inputTexture;
        uniform vec2 resolution;

        in vec2 vUv;
        out vec4 FragColor;

        void main() {
          ivec2 texel = ivec2(vUv.x * resolution.x, vUv.y * resolution.y);
          vec4 color = texelFetch(inputTexture, texel, 0);
          
          // Simple distance field - objects have alpha > 0
          float dist = color.a > 0.1 ? 0.0 : 0.01;
          
          FragColor = vec4(dist, 0.0, 0.0, 1.0);
        }`
      });
      
      // Setup GI pipeline
      const {uniforms: giUniforms, render: giRender, renderTargets: giRenderTargets} = mainPipeline.add({
        uniforms: {
          resolution: [this.width, this.height],
          oneOverSize: [1.0 / this.width, 1.0 / this.height],
          sceneTexture: null,
          distanceTexture: null,
          rayCount: 8, // Always use 8 rays for GI as requested
          maxSteps: 80,
          sunAngle: 0.4,
          enableSun: true,
          showGrain: false,
          showNoise: true,
        },
        fragmentShader: `
uniform int rayCount;
uniform float sunAngle;
uniform bool showNoise;
uniform bool showGrain;
uniform bool enableSun;
uniform vec2 oneOverSize;
uniform int maxSteps;

uniform sampler2D sceneTexture;
uniform sampler2D distanceTexture;

out vec4 FragColor;
in vec2 vUv;

const float PI = 3.14159265;
const float TAU = 2.0 * PI;
const float ONE_OVER_TAU = 1.0 / TAU;
const float PAD_ANGLE = 0.01;
const float EPS = 0.001f;

const vec3 skyColor = vec3(0.02, 0.08, 0.2);
const vec3 sunColor = vec3(0.95, 0.95, 0.9);
const float goldenAngle = PI * 0.7639320225;

// Popular rand function
float rand(vec2 co) {
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 sunAndSky(float rayAngle) {
    // Get the sun / ray relative angle
    float angleToSun = mod(rayAngle - sunAngle, TAU);

    // Sun falloff based on the angle
    float sunIntensity = smoothstep(1.0, 0.0, angleToSun);

    // And that's our sky radiance
    return sunColor * sunIntensity + skyColor;
}

bool outOfBounds(vec2 uv) {
    return uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0;
}

void main() {
    vec2 uv = vUv;

    vec4 light = texture(sceneTexture, uv);

    vec4 radiance = vec4(0.0);

    float oneOverRayCount = 1.0 / float(rayCount);
    float angleStepSize = TAU * oneOverRayCount;

    float coef = 0.0;
    float offset = showNoise ? rand(uv + coef) : 0.0;
    float rayAngleStepSize = showGrain ? angleStepSize + offset * TAU : angleStepSize;
    float minStepSize = min(oneOverSize.x, oneOverSize.y);

    // Not light source or occluder
    if (light.a < 0.1) {
        // Shoot rays in "rayCount" directions, equally spaced, with some randomness.
        for(int i = 0; i < rayCount; i++) {
            float angle = rayAngleStepSize * (float(i) + offset) + sunAngle;
            vec2 rayDirection = vec2(cos(angle), -sin(angle));

            vec2 sampleUv = uv;
            vec4 radDelta = vec4(0.0);
            bool hitSurface = false;

            // We tested uv already (we know we aren't an object), so skip step 0.
            for (int step = 1; step < maxSteps; step++) {
                // How far away is the nearest object?
                float dist = texture(distanceTexture, sampleUv).r;

                // Go the direction we're traveling (with noise)
                sampleUv += rayDirection * dist;

                if (outOfBounds(sampleUv)) break;

                if (dist <= minStepSize) {
                    vec4 sampleColor = texture(sceneTexture, sampleUv);
                    radDelta += sampleColor;
                    hitSurface = true;
                    break;
                }
            }

            // If we didn't find an object, add some sky + sun color
            if (!hitSurface && enableSun) {
                radDelta += vec4(sunAndSky(angle), 1.0);
            }

            // Accumulate total radiance
            radiance += radDelta;
        }
    } else if (length(light.rgb) >= 0.1) {
        radiance = light;
    }

    // Bring up all the values to have an alpha of 1.0.
    vec4 finalRadiance = vec4(max(light, radiance * oneOverRayCount).rgb, 1.0);
    FragColor = finalRadiance;
}`
      }, {
        internalFormat: mainPipeline.gl().RGBA16F,
      });

      // Create a layer for the main animation
      const mainLayer = new Layer(
        'main-layer',
        mainPipeline,
        (texture, _, previewAction) => {
          // Generate distance field
          dfRender({
            renderTarget: dfRenderTargets[0],
            uniforms: {
              inputTexture: texture,
            }
          });
          
          // Apply GI
          giRender({
            renderTarget: giRenderTargets[0],
            uniforms: {
              sceneTexture: texture,
              distanceTexture: dfRenderTargets[0].texture,
            }
          });
        },
        {
          ignorePanZoom: true,
          renderDuringPreviewAction: true,
          extras: {
            uniforms: giUniforms,
          },
        }
      );

      this.pushLayer(mainLayer);
    }

    *animationSequence() {
      // Canvas dimensions
      const { width, height } = this;
      const centerX = width / 2;
      const centerY = height / 2;

      // Set background
      this.animate([
        {
          layer: 'background',
          draw(ctx, _) {
            ctx.fillStyle = '#111122';
            ctx.fillRect(0, 0, width, height);
          }
        }
      ], { duration: 0 });

      // Create SVG container for our animation
      const svgContainer = document.createElement('div');
      svgContainer.style.position = 'absolute';
      svgContainer.style.top = '-9999px';
      svgContainer.style.left = '-9999px';
      document.body.appendChild(svgContainer);
      
      // Create SVG element for GSAP to manipulate
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('width', '100');
      svg.setAttribute('height', '100');
      svg.setAttribute('viewBox', '0 0 100 100');
      svgContainer.appendChild(svg);
      
      // Create morphing path
      const morphPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      morphPath.setAttribute('fill', '#ff5722');
      morphPath.setAttribute('d', document.getElementById('shape1').getAttribute('d'));
      svg.appendChild(morphPath);
      
      // Create bouncing circles
      const circles = [];
      const colors = ['#3498db', '#2ecc71', '#f1c40f', '#9b59b6', '#e74c3c'];
      
      for (let i = 0; i < 5; i++) {
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('r', '8');
        circle.setAttribute('cx', '20');
        circle.setAttribute('cy', '20');
        circle.setAttribute('fill', colors[i]);
        svg.appendChild(circle);
        circles.push(circle);
      }

      // Main animation - runs for 6 seconds total
      const duration = 6.0;
      
      this.animate([
        {
          layer: 'main-layer',
          draw(ctx, progress, { layers }) {
            ctx.clearRect(0, 0, width, height);
            
            // Set GI parameters based on progress
            if (layers['main-layer'].extras) {
              layers['main-layer'].extras.uniforms.sunAngle = progress * Math.PI * 2;
            }
            
            // Calculate animation progress for GSAP 
            // Map our 0-1 progress to GSAP's timeline
            const tProgress = progress * duration;
            
            // GSAP animations based on progress
            
            // Path morphing - three stages during the animation
            if (tProgress < 2.0) {
              // First morph: square to circle
              const morphProgress = Math.min(1, tProgress / 2.0);
              const shape1Path = document.getElementById('shape1').getAttribute('d');
              const shape2Path = document.getElementById('shape2').getAttribute('d');
              
              // Set morphing progress using GSAP
              gsap.set(morphPath, {
                morphSVG: {
                  shape: shape2Path,
                  shapeIndex: "auto",
                  map: "size",
                  precompile: true,
                  updateTarget: false
                },
                progress: gsap.utils.interpolate(0, 1, morphProgress)
              });
            } 
            else if (tProgress < 4.0) {
              // Second morph: circle to diamond
              const morphProgress = (tProgress - 2.0) / 2.0;
              const shape2Path = document.getElementById('shape2').getAttribute('d');
              const shape3Path = document.getElementById('shape3').getAttribute('d');
              
              // Set morphing progress
              gsap.set(morphPath, {
                morphSVG: {
                  shape: shape3Path,
                  shapeIndex: "auto",
                  map: "size",
                  precompile: true,
                  updateTarget: false
                },
                progress: gsap.utils.interpolate(0, 1, morphProgress)
              });
            }
            else {
              // Last morph: diamond back to square
              const morphProgress = (tProgress - 4.0) / 2.0;
              const shape3Path = document.getElementById('shape3').getAttribute('d');
              const shape1Path = document.getElementById('shape1').getAttribute('d');
              
              // Set morphing progress
              gsap.set(morphPath, {
                morphSVG: {
                  shape: shape1Path,
                  shapeIndex: "auto",
                  map: "size",
                  precompile: true,
                  updateTarget: false
                },
                progress: gsap.utils.interpolate(0, 1, morphProgress)
              });
            }
            
            // Animate circles with GSAP-like bouncing
            circles.forEach((circle, i) => {
              if (tProgress < 2.0) {
                // First movement
                const bounceProgress = Math.min(1, tProgress / 2.0);
                const ease = gsap.parseEase("bounce.out")(bounceProgress);
                
                const startX = 20;
                const startY = 20;
                const targetX = 50 + 30 * Math.cos(i * Math.PI * 0.4);
                const targetY = 50 + 30 * Math.sin(i * Math.PI * 0.4);
                
                const x = gsap.utils.interpolate(startX, targetX, ease);
                const y = gsap.utils.interpolate(startY, targetY, ease);
                
                circle.setAttribute('cx', x.toString());
                circle.setAttribute('cy', y.toString());
              }
              else if (tProgress < 4.0) {
                // Second movement
                const bounceProgress = (tProgress - 2.0) / 2.0;
                const ease = gsap.parseEase("bounce.out")(bounceProgress);
                
                const startX = 50 + 30 * Math.cos(i * Math.PI * 0.4);
                const startY = 50 + 30 * Math.sin(i * Math.PI * 0.4);
                const targetX = 50 + 30 * Math.cos(i * Math.PI * 0.8);
                const targetY = 50 + 30 * Math.sin(i * Math.PI * 0.8);
                
                const x = gsap.utils.interpolate(startX, targetX, ease);
                const y = gsap.utils.interpolate(startY, targetY, ease);
                
                circle.setAttribute('cx', x.toString());
                circle.setAttribute('cy', y.toString());
              }
              else {
                // Return to start
                const bounceProgress = (tProgress - 4.0) / 2.0;
                const ease = gsap.parseEase("power2.inOut")(bounceProgress);
                
                const startX = 50 + 30 * Math.cos(i * Math.PI * 0.8);
                const startY = 50 + 30 * Math.sin(i * Math.PI * 0.8);
                const targetX = 20 + i * 15;
                const targetY = 20;
                
                const x = gsap.utils.interpolate(startX, targetX, ease);
                const y = gsap.utils.interpolate(startY, targetY, ease);
                
                circle.setAttribute('cx', x.toString());
                circle.setAttribute('cy', y.toString());
              }
            });
            
            // Draw the SVG to the canvas
            ctx.save();
            ctx.translate(centerX - 150, centerY - 150);
            ctx.scale(3, 3);
            
            // Convert SVG to image and draw to canvas
            const svgData = new XMLSerializer().serializeToString(svg);
            const img = new Image();
            img.src = 'data:image/svg+xml;base64,' + btoa(svgData);
            
            // Draw image immediately (without waiting for onload)
            // This works because we're using a data URL
            if (img.complete) {
              ctx.drawImage(img, 0, 0);
            } else {
              img.onload = () => ctx.drawImage(img, 0, 0);
            }
            
            ctx.restore();
          }
        }
      ], { duration: duration, easing: Easing.linear });
    }
  }

  document.addEventListener('DOMContentLoaded', async () => {
    const app = document.querySelector("#preview");
    if (!app) return;

    // Create canvas with specified dimensions
    const canvas = document.createElement("canvas");
    const width = 400;
    const height = 400;
    canvas.width = width;
    canvas.height = height;
    app.append(canvas);

    // Create Mation instance with autoplay and loop
    const mation = new Mation({ 
      autoplay: true, 
      loop: true,
      showUI: true 
    });

    // Create scene with our dimensions
    const scene = new BouncyScene({canvas, width, height});

    // Set the scene and initialize
    mation.setScene(scene);
    await mation.initialize(app);
  });
</script>
</body>
</html>