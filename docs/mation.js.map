{"version":3,"file":"mation.js","sources":["../src/webgl.ts","../src/animation.ts","../src/easings.ts","../src/loaders.ts","../src/videoRenderer.ts","../src/styles.ts","../src/mation.ts"],"sourcesContent":["const prefix = `#version 300 es\nprecision highp float;\nprecision highp int;\n`;\n\n// Vertex Shader (shared by both passes)\nconst vertexShaderDefault = `in vec2 position;\nout vec2 vUv;\nvoid main() {\n    vUv = 0.5 * (position + 1.0);\n    gl_Position = vec4(position, 0.0, 1.0);\n}`;\n\nexport interface MaterialProperties {\n  fragmentShader: string;\n  vertexShader?: string;\n  uniforms: Record<string, any>;\n  name?: string;\n}\n\ninterface Attribute {\n  buffer: WebGLBuffer;\n  size: number;\n}\n\ninterface Attributes {\n  [key: string]: Attribute;\n}\n\ninterface RenderTargetProps {\n  generateMipmaps?: boolean;\n  minFilter?: number;\n  magFilter?: number;\n  internalFormat?: number;\n  format?: number;\n  type?: number;\n}\n\ninterface FramebufferInfo {\n  framebuffer: WebGLFramebuffer;\n  texture: WebGLTexture;\n  width: number;\n  height: number;\n}\n\nexport interface WebGLInitResult {\n  canvas: HTMLCanvasElement | OffscreenCanvas;\n  render: (options?: { uniforms?: Record<string, any>, renderTarget?: RenderTarget | null }) => void;\n  renderTargets: RenderTarget[];\n  renderer: WebGL2MicroLayer;\n  scaling: number;\n  uniforms: Record<string, any>;\n  gl: WebGL2RenderingContext;\n  stage: Pass;\n}\n\ninterface WebGLInitExtra {\n  dpr?: number;\n  scale?: boolean;\n  canvasScale?: number;\n  renderTargetCount?: number;\n}\n\nclass Pass {\n  private vertexShader: string;\n  private fragmentShader: string;\n  private program: WebGLProgram;\n  private quad: Attribute;\n  private name: string;\n  private w: WebGL2MicroLayer;\n  uniforms: Record<string, any>;\n\n  constructor(w: WebGL2MicroLayer, quad: Attribute, materialProperties: MaterialProperties) {\n    const {fragmentShader, vertexShader, uniforms, name} = materialProperties;\n    this.vertexShader = vertexShader ?? vertexShaderDefault;\n    this.fragmentShader = fragmentShader;\n    this.program = w.createProgram(\n      `${prefix}${this.vertexShader}`,\n      `${prefix}${this.fragmentShader}`\n    );\n    this.uniforms = uniforms;\n    this.quad = quad;\n    this.name = name || '';\n    w.programs.set(name || '', this.program);\n    this.w = w;\n  }\n\n  updateFragmentShader(fragmentShader: string): void {\n    this.fragmentShader = fragmentShader;\n    this.program = this.w.createProgram(\n      this.vertexShader,\n      `${prefix}${this.fragmentShader}`\n    );\n    this.w.programs.set(this.name, this.program);\n  }\n\n  set(updates: Record<string, any>): void {\n    Object.keys(updates).forEach((key) => {\n      this.uniforms[key] = updates[key];\n    });\n  }\n\n  render(options?: { uniforms?: Record<string, any>, renderTarget?: RenderTarget | null }): void {\n    if (options?.uniforms) {\n      this.set(options.uniforms);\n    }\n    if (typeof options?.renderTarget !== \"undefined\") {\n      this.w.setRenderTarget(options.renderTarget);\n    } else {\n      this.w.setRenderTarget(null);\n    }\n    this.w.render(\n      this.name,\n      this.uniforms,\n      {position: this.quad},\n    );\n  }\n}\n\nexport class WebGLPipeline {\n  w: WebGL2MicroLayer;\n  private quad: Attribute;\n  private passes: Record<string, Pass>;\n\n  constructor(w: WebGL2MicroLayer, quad: Attribute) {\n    this.w = w;\n    this.quad = quad;\n    this.passes = {};\n  }\n\n  add(\n    materialProperties: MaterialProperties,\n    renderTargetOverrides: RenderTargetProps = {},\n    extra: WebGLInitExtra = {},\n  ): WebGLInitResult {\n    const dpr = extra.dpr || window.devicePixelRatio || 1;\n    const scale = extra.scale ? dpr : 1.0;\n\n    const w = this.w;\n    const canvas = this.w.canvas;\n    const width = this.w.canvas.width;\n    const height = this.w.canvas.height;\n    \n    // Set the viewport to match the canvas size\n    w.gl.viewport(0, 0, canvas.width, canvas.height);\n\n    const renderTargetProps = {\n      minFilter: w.gl.NEAREST,\n      magFilter: w.gl.NEAREST,\n      internalFormat: w.gl.RGBA16F,\n      format: w.gl.RGBA,\n      type: w.gl.HALF_FLOAT,\n      ...renderTargetOverrides\n    };\n\n    const renderTargetCount = extra?.renderTargetCount ?? 2;\n    const renderTargets: RenderTarget[] = [];\n\n    for (let i = 0; i < renderTargetCount; i++) {\n      renderTargets.push(\n        w.createRenderTarget(width * scale, height * scale, renderTargetProps)\n      );\n    }\n\n    const pass = this.createPass(materialProperties);\n\n    return {\n      canvas,\n      render: (options?: { uniforms?: Record<string, any>, renderTarget?: RenderTarget | null }) => {\n        pass.render({ uniforms: options?.uniforms, renderTarget: options?.renderTarget });\n      },\n      renderTargets,\n      renderer: w,\n      scaling: dpr,\n      uniforms: pass.uniforms,\n      gl: this.gl(),\n      stage: pass,\n    };\n  }\n\n  createPass(materialProperties: MaterialProperties): Pass {\n    const {name} = materialProperties;\n    const passName = `pass-${Object.keys(this.passes).length}:-${name ?? \"\"}`;\n    const pass = new Pass(\n      this.w,\n      this.quad,\n      {\n        ...materialProperties,\n        name: passName,\n      },\n    );\n    this.passes[passName] = pass;\n    return pass;\n  }\n\n  gl() {\n    return this.w.gl;\n  }\n}\n\nclass RenderTarget {\n  private gl: WebGL2RenderingContext;\n  public name: string;\n  public texture: WebGLTexture;\n  public framebuffer: WebGLFramebuffer;\n\n  constructor(gl: WebGL2RenderingContext, name: string, texture: WebGLTexture, framebuffer: WebGLFramebuffer) {\n    this.gl = gl;\n    this.name = name;\n    this.texture = texture;\n    this.framebuffer = framebuffer;\n  }\n\n  updateFilters({minFilter, magFilter}: {minFilter: number, magFilter: number}): void {\n    this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, minFilter);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, magFilter);\n    this.gl.bindTexture(this.gl.TEXTURE_2D, null);\n  }\n}\n\nexport class WebGL2MicroLayer {\n  public canvas: HTMLCanvasElement | OffscreenCanvas;\n  public gl: WebGL2RenderingContext;\n  public programs: Map<string, WebGLProgram>;\n  public framebuffers: Map<string, FramebufferInfo>;\n  public defaultRenderTargetProps: RenderTargetProps;\n  public renderTargets: Record<string, RenderTarget>;\n\n  constructor(canvas: HTMLCanvasElement | OffscreenCanvas, extra?: {\n    canvasScale?: number;\n    dpr?: number;\n  }) {\n    this.canvas = canvas;\n    const dpr = extra?.dpr ?? (window.devicePixelRatio || 1);\n    const canvasScale = extra?.canvasScale ?? 1.0 / dpr;\n    const width = canvas.width;\n    const height = canvas.height;\n\n    if (\"style\" in canvas) {\n      canvas.style.width = `${width * canvasScale}px`;\n      canvas.style.height = `${height * canvasScale}px`;\n    }\n\n    const gl = canvas.getContext('webgl2', {antialiasing: false, alpha: false}) as WebGL2RenderingContext;\n    if (!gl) {\n      throw new Error('WebGL2 not supported');\n    }\n    this.gl = gl;\n    this.gl.getExtension(\"EXT_color_buffer_float\");\n    this.gl.getExtension(\"EXT_color_buffer_half_float\");\n    this.gl.getExtension(\"OES_texture_float_linear\");\n    this.gl.disable(this.gl.DEPTH_TEST);\n    this.gl.disable(this.gl.BLEND);\n    this.gl.disable(this.gl.SCISSOR_TEST);\n    this.gl.clearDepth(1.0);\n    this.gl.colorMask(true, true, true, true);\n\n    this.programs = new Map();\n    this.framebuffers = new Map();\n\n    this.defaultRenderTargetProps = {\n      minFilter: this.gl.NEAREST,\n      magFilter: this.gl.NEAREST,\n      internalFormat: this.gl.RGBA16F,\n      format: this.gl.RGBA,\n      type: this.gl.HALF_FLOAT\n    };\n    this.renderTargets = {};\n  }\n\n  createProgram(vertexShaderSource: string, fragmentShaderSource: string): WebGLProgram {\n    const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexShaderSource);\n    const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentShaderSource);\n\n    const program = this.gl.createProgram();\n    if (!program) {\n      throw new Error('Failed to create WebGL program');\n    }\n    \n    this.gl.attachShader(program, vertexShader);\n    this.gl.attachShader(program, fragmentShader);\n    this.gl.linkProgram(program);\n\n    if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {\n      throw new Error('Unable to initialize the shader program: ' + this.gl.getProgramInfoLog(program));\n    }\n\n    return program;\n  }\n\n  addLineNumbers(source: string): string {\n    return source.split('\\n').map((line, index) => `${index + 1}: ${line}`).join('\\n');\n  }\n\n  createShader(type: number, source: string): WebGLShader {\n    const shader = this.gl.createShader(type);\n    if (!shader) {\n      throw new Error('Failed to create WebGL shader');\n    }\n    \n    this.gl.shaderSource(shader, source);\n    this.gl.compileShader(shader);\n\n    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {\n      throw new Error('An error occurred compiling the shaders: ' + this.gl.getShaderInfoLog(shader) + `\\n${this.addLineNumbers(source)}`);\n    }\n\n    return shader;\n  }\n\n  createTextureFromImage(path: string, cb?: () => void): WebGLTexture {\n    const gl = this.gl;\n    const texture = gl.createTexture();\n    if (!texture) {\n      throw new Error('Failed to create WebGL texture');\n    }\n    // Asynchronously load an image\n    const image = new Image();\n    image.src = path;\n    const self = this;\n    image.onload = function() {\n      // Create a temporary canvas to flip the image\n      const tempCanvas = document.createElement('canvas');\n      tempCanvas.width = image.width;\n      tempCanvas.height = image.height;\n      const tempCtx = tempCanvas.getContext('2d');\n      if (!tempCtx) {\n        throw new Error('Failed to get 2D context');\n      }\n\n      tempCtx.drawImage(image, 0, image.height);\n\n      self.createTextureFromCanvas(tempCanvas);\n\n      if (cb) {\n        cb();\n      }\n    };\n\n    return texture;\n  }\n  \n  createTextureFromCanvas(canvas: HTMLCanvasElement | OffscreenCanvas): WebGLTexture {\n    const gl = this.gl;\n    const texture = gl.createTexture();\n    if (!texture) {\n      throw new Error('Failed to create WebGL texture');\n    }\n\n    const tempCtx = canvas.getContext('2d');\n    if (!tempCtx) {\n      throw new Error('Failed to get 2D context');\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n    // Tell WebGL to flip the Y axis when unpacking the texture\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);\n    // Reset the pixel store parameter to its default\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.bindTexture(gl.TEXTURE_2D, null);\n\n    return texture;\n  }\n\n  createRenderTarget(width: number, height: number, overrides: RenderTargetProps = {}, name?: string): RenderTarget {\n    const {\n      // generateMipmaps,\n      minFilter,\n      magFilter,\n      internalFormat,\n      format,\n      type\n    } = {\n      ...(this.defaultRenderTargetProps),\n      ...overrides\n    };\n\n    const renderTargetName = name ?? `rt-${Object.keys(this.renderTargets).length}`;\n\n    const framebuffer = this.gl.createFramebuffer();\n    if (!framebuffer) {\n      throw new Error('Failed to create framebuffer');\n    }\n    \n    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, framebuffer);\n\n    const texture = this.gl.createTexture();\n    if (!texture) {\n      throw new Error('Failed to create texture');\n    }\n    \n    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);\n    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, internalFormat!, width, height, 0, format!, type!, null);\n\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, minFilter!);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, magFilter!);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\n\n    this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, texture, 0);\n    //this.clear();\n\n    const status = this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER);\n    if (status !== this.gl.FRAMEBUFFER_COMPLETE) {\n      throw new Error('Framebuffer is not complete: ' + status);\n    }\n\n    // Unbind the frame buffer and texture.\n    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n    this.gl.bindTexture(this.gl.TEXTURE_2D, null);\n\n    this.framebuffers.set(renderTargetName, {framebuffer, texture, width, height});\n    this.renderTargets[renderTargetName] = new RenderTarget(\n      this.gl, renderTargetName, texture, framebuffer\n    );\n    return this.renderTargets[renderTargetName];\n  }\n\n  setRenderTargetInternal(name: string | null): void {\n    if (name === null) {\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n      this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);\n    } else {\n      const target = this.framebuffers.get(name);\n      if (!target) {\n        throw new Error(`Render target \"${name}\" not found`);\n      }\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, target.framebuffer);\n      this.gl.viewport(0, 0, target.width, target.height);\n    }\n  }\n\n  setRenderTarget(renderTarget: RenderTarget | null): void {\n    return this.setRenderTargetInternal(renderTarget?.name ?? null);\n  }\n\n  clear(): void {\n    this.gl.clearColor(0.0, 0.0, 0.0, 0.0);\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT | this.gl.STENCIL_BUFFER_BIT);\n  }\n\n  getRenderTargetTexture(name: string): WebGLTexture {\n    const target = this.framebuffers.get(name);\n    if (!target) {\n      throw new Error(`Render target \"${name}\" not found`);\n    }\n    return target.texture;\n  }\n\n  setUniform(\n    gl: WebGL2RenderingContext, \n    textureUnits: number[], \n    numUniforms: number, \n    program: WebGLProgram,\n    name: string, \n    value: any\n  ): void {\n    const location = gl.getUniformLocation(program, name);\n    if (location === null) {\n      // console.warn(`Uniform \"${name}\" not found in the shader program.`);\n      return;\n    }\n\n    // Get uniform info\n    let uniformInfo: WebGLActiveInfo | null = null;\n    for (let i = 0; i < numUniforms; i++) {\n      const info = gl.getActiveUniform(program, i);\n      if (info && info.name === name) {\n        uniformInfo = info;\n        break;\n      }\n    }\n\n    if (!uniformInfo) {\n      console.warn(`Unable to find uniform info for \"${name}\"`);\n      return;\n    }\n\n    const {type, size} = uniformInfo;\n\n    // Helper function to ensure array is of the correct type\n    function ensureTypedArray<T extends Float32Array | Int32Array>(arr: any, Type: new(buffer: ArrayBufferLike) => T): T {\n      return arr instanceof Type ? arr : new Type(arr);\n    }\n\n    switch (type) {\n      // Scalars\n      case gl.FLOAT:\n        gl.uniform1f(location, value);\n        break;\n      case gl.INT:\n      case gl.BOOL:\n        gl.uniform1i(location, value);\n        break;\n\n      // Vectors\n      case gl.FLOAT_VEC2:\n        gl.uniform2fv(location, ensureTypedArray(value, Float32Array));\n        break;\n      case gl.FLOAT_VEC3:\n        gl.uniform3fv(location, ensureTypedArray(value, Float32Array));\n        break;\n      case gl.FLOAT_VEC4:\n        gl.uniform4fv(location, ensureTypedArray(value, Float32Array));\n        break;\n      case gl.INT_VEC2:\n      case gl.BOOL_VEC2:\n        gl.uniform2iv(location, ensureTypedArray(value, Int32Array));\n        break;\n      case gl.INT_VEC3:\n      case gl.BOOL_VEC3:\n        gl.uniform3iv(location, ensureTypedArray(value, Int32Array));\n        break;\n      case gl.INT_VEC4:\n      case gl.BOOL_VEC4:\n        gl.uniform4iv(location, ensureTypedArray(value, Int32Array));\n        break;\n\n      // Matrices\n      case gl.FLOAT_MAT2:\n        gl.uniformMatrix2fv(location, false, ensureTypedArray(value, Float32Array));\n        break;\n      case gl.FLOAT_MAT3:\n        gl.uniformMatrix3fv(location, false, ensureTypedArray(value, Float32Array));\n        break;\n      case gl.FLOAT_MAT4:\n        gl.uniformMatrix4fv(location, false, ensureTypedArray(value, Float32Array));\n        break;\n\n      // Sampler types\n      case gl.SAMPLER_2D:\n      case gl.SAMPLER_CUBE:\n        const textureUnit = textureUnits.length;\n        this.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);\n        textureUnits.push(textureUnit);\n        this.gl.bindTexture(this.gl.TEXTURE_2D, value);\n        this.gl.uniform1i(location, textureUnit);\n\n\n        // Can we disable this if not using mipmaps?\n        // if (generateMipmaps) {\n        if (value != null) {\n          this.gl.generateMipmap(this.gl.TEXTURE_2D);\n        }\n        // }\n        break;\n\n      // Arrays\n      default:\n        if (type === gl.FLOAT && size > 1) {\n          gl.uniform1fv(location, ensureTypedArray(value, Float32Array));\n        } else if ((type === gl.INT || type === gl.BOOL) && size > 1) {\n          gl.uniform1iv(location, ensureTypedArray(value, Int32Array));\n        } else {\n          console.warn(`Unsupported uniform type: ${type}`);\n        }\n        break;\n    }\n  }\n\n  render(programName: string, uniforms: Record<string, any> = {}, attributes: Attributes = {}): void {\n    const program = this.programs.get(programName);\n    if (!program) {\n      throw new Error(`Program \"${programName}\" not found`);\n    }\n\n    this.gl.useProgram(program);\n\n    // Already has the font-image\n    const textureUnits: number[] = [];\n\n    const numUniforms = this.gl.getProgramParameter(program, this.gl.ACTIVE_UNIFORMS);\n\n    for (const [name, value] of Object.entries(uniforms)) {\n      this.setUniform(this.gl, textureUnits, numUniforms, program, name, value);\n    }\n\n    for (const [name, value] of Object.entries(attributes)) {\n      const location = this.gl.getAttribLocation(program, name);\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, value.buffer);\n      this.gl.enableVertexAttribArray(location);\n      this.gl.vertexAttribPointer(location, value.size, this.gl.FLOAT, false, 0, 0);\n    }\n\n    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);\n  }\n\n  createFullscreenQuad(): Attribute {\n    const buffer = this.gl.createBuffer();\n    if (!buffer) {\n      throw new Error('Failed to create buffer');\n    }\n    \n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);\n    this.gl.bufferData(\n      this.gl.ARRAY_BUFFER,\n      new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]),\n      this.gl.STATIC_DRAW\n    );\n    return {buffer, size: 2};\n  }\n\n  createPipeline(): WebGLPipeline {\n    // Create fullscreen quad\n    const fullscreenQuad = this.createFullscreenQuad();\n\n    return new WebGLPipeline(this, fullscreenQuad);\n  }\n\n  cleanup() {\n    this.clear();\n\n    // Delete any render targets with this layer's name\n    // Object.values(this.renderTargets).forEach(rt => {\n    //   const texture = rt.texture;\n    //   this.gl.deleteTexture(texture);\n    // });\n\n    // Array.from(this.framebuffers.entries()).forEach(([key, framebuffer]) => {\n    //   this.gl.deleteFramebuffer(framebuffer);\n    //   this.framebuffers.delete(key);\n    // });\n  }\n}\n\nexport function buildWebGlPipeline(canvas: HTMLCanvasElement | OffscreenCanvas): WebGLPipeline {\n  const w = new WebGL2MicroLayer(canvas);\n  return w.createPipeline();\n}\n\n","// Animation primitives\nimport {EasingFunction} from \"./easings.ts\";\nimport {buildWebGlPipeline, WebGLInitResult, WebGLPipeline} from \"./webgl.ts\";\n\n/**\n * Interface defining the requirements for any Mation Scene\n * Developers can either extend the base Scene class or implement this interface\n * to create custom scenes compatible with the Mation library.\n */\nexport interface IScene {\n  // Required properties\n  canvas: HTMLCanvasElement;\n  ctx: OffscreenCanvasRenderingContext2D;\n  width: number;\n  height: number;\n  \n  // Core animation methods\n  setupLayers(): void;\n  animationSequence(): Generator<Promise<void>, void, unknown>;\n  \n  // Animation control methods\n  play(): void;\n  pause(): void;\n  playing(): boolean;\n  seekToTime(time: number): void;\n  \n  // State getters\n  getCurrentTime(): number;\n  getDuration(): number;\n  \n  // Rendering methods\n  queueRender(): void;\n  renderAtTime(time: number): void;\n  \n  // Zoom and pan controls\n  setZoom(value: number): void;\n  setPan(value: [number, number]): void;\n  setMousePosition(x: number, y: number): void;\n  setForceDefaultLayerOnly(value: boolean): void;\n\n  setTargetFPS(fps: number): void;\n\n  runSequence(): Promise<void>;\n  get zoom(): number\n  set zoom(value: number);\n  get pan(): [number, number];\n  set pan(value: [number, number]);\n}\n\ninterface AnimationOptions {\n  duration: number;\n  easing?: EasingFunction;\n  delay?: number;\n  parallel?: boolean;\n}\n\nexport interface DrawableElement {\n  draw(ctx: OffscreenCanvasRenderingContext2D, progress: number, extras: { layers: Record<string, Layer> }): void;\n  update?(progress: number): void;\n  layer?: string | string[];\n  segmentStartTime?: number; // Track when element was added\n}\n\nexport class Layer {\n  public name: string;\n  public x?: number;\n  public y?: number;\n  public width?: number;\n  public height?: number;\n  public isSubview?: boolean;\n  public renderWhenScrubbing?: boolean;\n  public extras?: Record<string, any>;\n  private pipeline: WebGLPipeline;\n  public ignorePanZoom?: boolean;\n  render: (texture: WebGLTexture, progress: number) => void;\n\n  constructor(\n    name: string, \n    pipeline: WebGLPipeline,\n    render: (texture: WebGLTexture, progress: number) => void,\n    options: {\n      x?: number;\n      y?: number;\n      width?: number;\n      height?: number;\n      isSubview?: boolean;\n      renderWhenScrubbing?: boolean;\n      ignorePanZoom?: boolean;\n      extras?: Record<string, any>;\n    } = {}\n  ) {\n    this.name = name;\n    this.pipeline = pipeline;\n    this.render = render;\n    this.x = options.x;\n    this.y = options.y;\n    this.width = options.width;\n    this.height = options.height;\n    this.isSubview = options.isSubview;\n    this.renderWhenScrubbing = options.renderWhenScrubbing;\n    this.ignorePanZoom = options.ignorePanZoom;\n    this.extras = options.extras;\n  }\n  \n  cleanup(): void {\n    this.pipeline.w.cleanup();\n  }\n}\n\nconst defaultShader = {\n  fragmentShader: `in vec2 vUv;\nout vec4 fragColor;\nuniform sampler2D u_texture;\nuniform float u_progress;\n\nvoid main() {\n  fragColor = texture(u_texture, vUv);\n}`,\n  uniforms: {\n    u_texture: null,\n    u_progress: 0.0\n  }\n};\n\nexport interface AnimationSegment {\n  startTime: number;\n  duration: number;\n  elements: DrawableElement[];\n  easing: EasingFunction;\n}\n\n/**\n * Base Scene class that implements the IScene interface\n * This class provides the core implementation that handles animation,\n * rendering, and interactions. Users can extend this class to create their\n * own scenes.\n */\nexport class Scene implements IScene {\n  canvas: HTMLCanvasElement;\n  ctx: OffscreenCanvasRenderingContext2D;\n  width: number;\n  height: number;\n  private _zoom: number = 1.0;\n  private _pan: [number, number] = [0.0, 0.0];\n  private mousePosition: [number, number] = [0, 0];\n  \n  get zoom(): number {\n    return this._zoom;\n  }\n  \n  set zoom(value: number) {\n    this._zoom = value;\n    this.savePlayerState();\n  }\n  \n  get pan(): [number, number] {\n    return this._pan;\n  }\n  \n  set pan(value: [number, number]) {\n    this._pan = value;\n    this.savePlayerState();\n  }\n  \n  setMousePosition(x: number, y: number): void {\n    this.mousePosition = [x * window.devicePixelRatio, y * window.devicePixelRatio];\n  }\n\n  // Add debug logging to setZoom to see what's happening\n  setZoom(value: number): void {\n    // Get mouse position in screen space\n    const [mouseX, mouseY] = this.mousePosition;\n\n    // Calculate the world coordinates of the mouse point\n    const worldX = (mouseX - this._pan[0]) / this._zoom;\n    const worldY = (mouseY - this._pan[1]) / this._zoom;\n\n    // Update the zoom level\n    this._zoom = value;\n\n    // Calculate new pan to keep the world point under the mouse cursor\n    const newPanX = mouseX - worldX * this._zoom;\n    const newPanY = mouseY - worldY * this._zoom;\n\n    // Update pan values\n    this._pan[0] = newPanX;\n    this._pan[1] = newPanY;\n\n    // this.setForceDefaultLayerOnly(true);\n    // Queue render with updated transforms\n    this.queueRender();\n    this.savePlayerState();\n  }\n  \n  setPan(value: [number, number]): void {\n    this._pan = value;\n    this.setForceDefaultLayerOnly(true);\n    // Queue render with updated transforms\n    this.queueRender();\n    this.savePlayerState();\n  }\n\n  private animationId: number | null = null;\n  private texturePipelineResult: WebGLInitResult;\n  private layers: Layer[] = [];\n  private layerLookup: Record<string, Layer> = {};\n  private layerInitialProperties: Record<string, any> = {};\n  private layerCanvases: Record<string, OffscreenCanvas> = {};\n  private layerElements: Record<string, DrawableElement[]> = {};\n  private defaultLayerElements: DrawableElement[] = [];\n  private defaultLayerCanvas: OffscreenCanvas;\n  private onFrame?: () => void;\n\n  // WebGL texture cache\n  private textureCache: Record<string, WebGLTexture> = {};\n  \n  // Animation timeline properties\n  private animationSegments: AnimationSegment[] = [];\n  private isPlaying: boolean = true;\n  private currentTime: number = 0;\n  private totalDuration: number = 0;\n  private lastRenderTime: number = 0;\n  private forceDefaultLayerOnly: boolean = false;\n  private renderQueued: boolean = false;\n  private targetFPS: number = 60;\n  private frameInterval: number = (1000 / 60) / 1000; // 16.67ms for 60fps\n  \n  // State persistence key\n  private static readonly PLAYER_STATE_KEY = 'mation_player_state';\n\n  constructor({canvas, width, height}: {\n    canvas: HTMLCanvasElement,\n    width: number,\n    height: number\n  }) {\n    this.canvas = canvas;\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.width = width;\n    this.height = height;\n    const { ctx, texturePipelineResult, defaultLayerCanvas } = this.initialize();\n    this.ctx = ctx;\n    this.texturePipelineResult = texturePipelineResult;\n    this.defaultLayerCanvas = defaultLayerCanvas;\n  }\n\n  initialize() {\n    // Create a main drawing canvas\n    const drawingCanvas = new OffscreenCanvas(this.width, this.height);\n    drawingCanvas.width = this.width;\n    drawingCanvas.height = this.height;\n    const ctx = drawingCanvas.getContext('2d');\n    if (!ctx) throw new Error('Failed to get 2D context');\n    this.ctx = ctx;\n\n    // Initialize the default pipeline with the default shader\n    // This pipeline renders directly to the main canvas\n    const defaultPipeline = buildWebGlPipeline(this.canvas);\n    this.texturePipelineResult = defaultPipeline.add(defaultShader);\n\n    // Initialize default layer canvas\n    this.defaultLayerCanvas = new OffscreenCanvas(this.canvas.width, this.canvas.height);\n\n    this.setupLayers();\n    \n    // Try to restore player state from previous session\n    this.restorePlayerState();\n\n    return {\n      ctx, texturePipelineResult: this.texturePipelineResult, defaultLayerCanvas: this.defaultLayerCanvas\n    }\n  }\n\n  insertLayer(index: number, layer: Layer): void {\n    // Store initial layer properties as a separate object\n    this.layerInitialProperties[layer.name] = {\n      x: layer.x,\n      y: layer.y,\n      width: layer.width,\n      height: layer.height,\n      isSubview: layer.isSubview,\n      renderWhenScrubbing: layer.renderWhenScrubbing,\n      extras: layer.extras ? {...layer.extras} : undefined\n    };\n    \n    this.layerLookup[layer.name] = layer;\n    this.layers.splice(index, 0, layer);\n    this.layerElements[layer.name] = [];\n    const width = layer.width ?? this.canvas.width;\n    const height = layer.height ?? this.canvas.height;\n    this.layerCanvases[layer.name] = new OffscreenCanvas(width, height);\n  }\n\n  pushLayer(layer: Layer): void {\n    // Store initial layer properties as a separate object\n    this.layerInitialProperties[layer.name] = {\n      x: layer.x,\n      y: layer.y,\n      width: layer.width,\n      height: layer.height,\n      isSubview: layer.isSubview,\n      renderWhenScrubbing: layer.renderWhenScrubbing,\n      extras: layer.extras ? {...layer.extras} : undefined\n    };\n    \n    this.layerLookup[layer.name] = layer;\n    this.layers.push(layer);\n    this.layerElements[layer.name] = [];\n    this.layerCanvases[layer.name] = new OffscreenCanvas(\n      this.canvas.width, this.canvas.height\n    );\n  }\n\n  getLayer(layerName: string): Layer {\n    return this.layerLookup[layerName];\n  }\n\n  registerElement(element: DrawableElement): void {\n    if (element.layer) {\n      if (Array.isArray(element.layer)) {\n        // Register to multiple layers\n        for (const layerName of element.layer) {\n          if (this.layerLookup[layerName]) {\n            this.layerElements[layerName].push(element);\n          }\n        }\n      } else if (this.layerLookup[element.layer]) {\n        // Register to a single layer\n        this.layerElements[element.layer].push(element);\n      } else {\n        // Layer doesn't exist, add to default\n        this.defaultLayerElements.push(element);\n      }\n    } else {\n      // No layer specified, add to default\n      this.defaultLayerElements.push(element);\n    }\n  }\n\n  clear(): void {\n    this.texturePipelineResult.renderer.cleanup();\n    // Clean up any render targets from the pipeline that belong to this layer\n\n    this.layers.forEach((layer) => {\n      layer.cleanup();\n    });\n\n    // Only clear canvases, not the element collections\n    const defaultCtx = this.defaultLayerCanvas.getContext('2d')!;\n    defaultCtx.clearRect(0, 0, this.defaultLayerCanvas.width, this.defaultLayerCanvas.height);\n\n    for (const layerName in this.layerCanvases) {\n      const ctx = this.layerCanvases[layerName].getContext('2d')!;\n      ctx.clearRect(0, 0, this.layerCanvases[layerName].width, this.layerCanvases[layerName].height);\n    }\n  }\n  \n  // Create or retrieve a cached texture for a canvas\n  private getTextureForCanvas(canvas: OffscreenCanvas): WebGLTexture {\n    const canvasKey = canvas === this.defaultLayerCanvas ? 'default' : canvas.toString();\n    \n    if (!this.textureCache[canvasKey]) {\n      // Create a new texture if one doesn't exist\n      this.textureCache[canvasKey] = this.texturePipelineResult.renderer.createTextureFromCanvas(canvas);\n    } else {\n      // Update the existing texture with new canvas content\n      const gl = this.texturePipelineResult.gl;\n      gl.bindTexture(gl.TEXTURE_2D, this.textureCache[canvasKey]);\n      // Tell WebGL to flip the Y axis when unpacking the texture\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);\n      // Reset the pixel store parameter to its default\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n    }\n    \n    return this.textureCache[canvasKey];\n  }\n  \n  // Method to clear all elements and reset\n  reset(): void {\n    this.clear();\n    this.animationSegments = [];\n    this.defaultLayerElements = [];\n    \n    // Clean up any layer-specific WebGL resources\n    for (const layerName in this.layerElements) {\n      const layer = this.layerLookup[layerName];\n      if (layer) {\n        layer.cleanup();\n      }\n      this.layerElements[layerName] = [];\n    }\n    \n    this.currentTime = 0;\n    this.totalDuration = 0;\n    \n    // Clean up WebGL texture cache\n    const gl = this.texturePipelineResult.gl;\n    for (const key in this.textureCache) {\n      gl.deleteTexture(this.textureCache[key]);\n    }\n    this.textureCache = {};\n    \n    // Clear saved player state\n    this.clearPlayerState();\n  }\n  \n  // Player state persistence methods\n  private savePlayerState(): void {\n    const state = {\n      currentTime: this.currentTime,\n      isPlaying: this.isPlaying,\n      totalDuration: this.totalDuration,\n      zoom: this._zoom,\n      pan: this._pan\n    };\n    try {\n      localStorage.setItem(Scene.PLAYER_STATE_KEY, JSON.stringify(state));\n    } catch (e) {\n      console.warn('Failed to save player state:', e);\n    }\n  }\n  \n  private restorePlayerState(): void {\n    try {\n      const savedState = localStorage.getItem(Scene.PLAYER_STATE_KEY);\n      if (savedState) {\n        const state = JSON.parse(savedState);\n        console.log('Found saved state:', state);\n        \n        // Store the values but don't apply the time yet - we need to wait until the animation\n        // is fully loaded to validate these values against the new timeline\n        \n        // Explicitly set isPlaying state - important to match UI state\n        if (state.isPlaying !== undefined) {\n          this.isPlaying = state.isPlaying;\n          console.log(`Restored playing state: ${this.isPlaying}`);\n        }\n        \n        // Store current time but don't apply until timeline is built\n        // It will be applied in runSequence() after buildAnimationTimeline()\n        if (state.currentTime !== undefined) {\n          this.currentTime = state.currentTime;\n          console.log(`Stored time for later restoration: ${this.currentTime}`);\n        }\n        \n        // Restore zoom and pan state\n        if (state.zoom !== undefined) {\n          this._zoom = state.zoom;\n          console.log(`Restored zoom: ${this._zoom}`);\n        }\n        \n        if (state.pan !== undefined) {\n          this._pan = state.pan;\n          console.log(`Restored pan: ${this._pan}`);\n        }\n      } else {\n        console.log('No saved player state found');\n      }\n    } catch (e) {\n      console.warn('Failed to restore player state:', e);\n    }\n  }\n  \n  private clearPlayerState(): void {\n    try {\n      localStorage.removeItem(Scene.PLAYER_STATE_KEY);\n    } catch (e) {\n      console.warn('Failed to clear player state:', e);\n    }\n  }\n\n  apply(fn: (ctx: OffscreenCanvasRenderingContext2D) => void) {\n    fn(this.ctx);\n  }\n\n  /**\n   * Setup layers for the scene\n   * This method can be implemented by any Scene subclass to define the layers\n   * used in the animation.\n   */\n  setupLayers(): void {}\n\n  /**\n   * Define the animation sequence\n   * This generator function must be implemented by any Scene subclass to create\n   * the animation timeline.\n   * Use yield this.animate(...) to create animation segments.\n   * @example\n   * *animationSequence() {\n   *   yield this.animate([myElement], { duration: 1.0 });\n   * }\n   */\n  *animationSequence(): Generator<Promise<void>, void, unknown> {\n    // Must be implemented by subclass\n    throw new Error('animationSequence() must be implemented by Scene subclass');\n  }\n\n  // Method to run a sequence of animations and build the timeline\n  async runSequence(): Promise<void> {\n    this.clear();\n    \n    // Store old state to restore later\n    const oldDuration = this.totalDuration;\n    const oldTime = this.currentTime;\n    const wasPlaying = this.isPlaying;\n    \n    // Temporarily reset timeline state to build it\n    const tempCurrentTime = this.currentTime;\n    this.currentTime = 0;\n    this.totalDuration = 0;\n    this.animationSegments = [];\n    this.lastRenderTime = 0;\n    \n    // First run the sequence to collect all segments and calculate total duration\n    await this.buildAnimationTimeline();\n    \n    // Now restore the previous state with validation for new timeline\n    if (oldTime > 0 || tempCurrentTime > 0) {\n      // Use the larger of stored time or previous current time\n      const timeToRestore = Math.max(oldTime, tempCurrentTime);\n      \n      // If duration changed and time is beyond new duration, reset to start or end\n      // Otherwise, restore the previous time position\n      if (oldDuration !== this.totalDuration && timeToRestore > this.totalDuration) {\n        // If we were at the end, stay at the end, otherwise go to start\n        this.currentTime = (timeToRestore >= oldDuration) ? this.totalDuration : 0;\n      } else {\n        this.currentTime = Math.min(timeToRestore, this.totalDuration);\n      }\n    }\n    \n    // Restore play state\n    this.isPlaying = wasPlaying;\n    \n    // Force a render at the current time to show the correct frame\n    this.renderAtTime(this.currentTime);\n    \n    // Only start the animation loop if actually playing\n    if (this.isPlaying) {\n      this.lastRenderTime = performance.now();\n      this.startAnimationLoop();\n    }\n    \n    // Save the state after restoration\n    this.savePlayerState();\n    \n    return Promise.resolve();\n  }\n  \n  // Build timeline by running through the animation sequence once\n  private async buildAnimationTimeline(): Promise<void> {\n    this.ctx.save();\n    const sequence = this.animationSequence();\n    let result = sequence.next();\n\n    while (!result.done) {\n      // Just collect the segments but don't render anything yet\n      await result.value;\n      result = sequence.next();\n    }\n    \n    this.ctx.restore();\n    console.log(`Animation timeline built with ${this.animationSegments.length} segments, total duration: ${this.totalDuration}s`);\n  }\n  \n  // Animation control methods\n  play(): void {\n    if (!this.isPlaying) {\n      // If we're at the end of the animation, loop back to start\n      if (this.currentTime >= this.totalDuration) {\n        this.currentTime = 0;\n      }\n      \n      this.isPlaying = true;\n      this.lastRenderTime = performance.now();\n      this.startAnimationLoop();\n      this.savePlayerState();\n    }\n  }\n  \n  pause(): void {\n    if (this.isPlaying) {\n      this.isPlaying = false;\n      if (this.animationId) {\n        cancelAnimationFrame(this.animationId);\n        this.animationId = null;\n      }\n      this.savePlayerState();\n    }\n  }\n\n  playing(): boolean {\n    return this.isPlaying;\n  }\n  \n  togglePlayPause(): void {\n    if (this.isPlaying) {\n      this.pause();\n    } else {\n      this.play();\n    }\n  }\n  \n  getDuration(): number {\n    return this.totalDuration;\n  }\n  \n  getCurrentTime(): number {\n    return this.currentTime;\n  }\n  \n  // Queue a render request that will be processed at the target FPS\n  queueRender(): void {\n    // Always set renderQueued to true when queueRender is called\n    this.renderQueued = true;\n    \n    // Start the render loop if it's not already running\n    if (!this.animationId) {\n      this.lastRenderTime = performance.now();  // Reset lastRenderTime to avoid jumps\n      this.animationId = requestAnimationFrame(this.renderLoop);\n    }\n  }\n\n  // Set the target FPS for rendering\n  setTargetFPS(fps: number): void {\n    this.targetFPS = Math.max(1, fps);\n    this.frameInterval = (1000 / this.targetFPS) / 1000;\n  }\n\n  // Start the main animation loop\n  private startAnimationLoop(): void {\n    if (this.animationId) {\n      cancelAnimationFrame(this.animationId);\n    }\n    \n    // Set renderQueued to true when playing to ensure continuous rendering\n    this.renderQueued = true;\n    \n    // Start the render loop which will respect target FPS\n    this.renderLoop();\n  }\n  \n  // Main render loop that respects target FPS\n  private renderLoop = (): void => {\n    const now = performance.now();\n    const elapsed = now - this.lastRenderTime;\n    \n    // Only render if enough time has passed (target FPS) or if we're just starting\n    if (elapsed >= this.frameInterval || this.lastRenderTime === 0) {\n      // Update the last render time regardless of what we're doing\n      this.lastRenderTime = now;\n      \n      // Update time for playing animations\n      if (this.isPlaying) {\n        const deltaTime = elapsed / 1000; // Convert to seconds\n        \n        // Update current time with clamping to valid range\n        const prevTime = this.currentTime;\n        this.currentTime = Math.min(this.currentTime + deltaTime, this.totalDuration);\n        \n        // Render at the current time\n        this.renderAtTime(this.currentTime);\n        \n        // Save current player state\n        this.savePlayerState();\n        \n        // Call onFrame callback if provided\n        if (this.onFrame) {\n          this.onFrame();\n        }\n        \n        // Check if we reached the end of animation\n        if (this.currentTime >= this.totalDuration) {\n          // We reached the end, stop the animation\n          this.isPlaying = false;\n          \n          // Ensure we render the final frame\n          if (prevTime < this.totalDuration) {\n            this.renderAtTime(this.totalDuration);\n          }\n          \n          // Save player state after stopping\n          this.savePlayerState();\n        }\n      } else if (this.renderQueued) {\n        // If not playing but render is queued, render at current time\n        this.renderAtTime(this.currentTime);\n        // Reset renderQueued flag after rendering once\n        this.renderQueued = false;\n      }\n    }\n    \n    // Always keep renderQueued true while playing\n    if (this.isPlaying) {\n      this.renderQueued = true;\n    }\n    \n    // Continue the loop if playing or if render is queued\n    if (this.isPlaying || this.renderQueued) {\n      this.animationId = requestAnimationFrame(this.renderLoop);\n    } else {\n      this.animationId = null;\n    }\n  }\n  \n  // Render the animation at a specific time\n  renderAtTime(time: number): void {\n    // Clamp time to valid range\n    const targetTime = Math.max(0, Math.min(time, this.totalDuration));\n    this.currentTime = targetTime;\n\n    // Clear the canvas\n    this.clear();\n    \n    // Find all segments that should be visible at this time\n    // This includes any segment that started before or at the current time\n    const visibleSegments = this.animationSegments.filter(segment => {\n      return segment.startTime <= targetTime;\n    });\n    \n    // Sort segments by start time to ensure proper rendering order\n    visibleSegments.sort((a, b) => a.startTime - b.startTime);\n\n    // Collect all visible elements and their progress values\n    const visibleElements = new Map<DrawableElement, number>();\n    \n    // Process each visible segment to determine element progress\n    for (const segment of visibleSegments) {\n      const segmentElapsedTime = targetTime - segment.startTime;\n      \n      // If the segment has completed, use progress of 1.0 (fully rendered)\n      // Otherwise calculate the appropriate progress value\n      let progress;\n      if (segmentElapsedTime >= segment.duration) {\n        progress = 1.0; // Fully complete\n      } else {\n        progress = Math.max(0, Math.min(segmentElapsedTime / segment.duration, 1.0));\n        // Apply easing to the progress\n        progress = segment.easing(progress);\n      }\n      \n      // Add each element with its progress value\n      for (const element of segment.elements) {\n        visibleElements.set(element, progress);\n      }\n    }\n    \n    // Now render all visible elements using the current element collections\n    this.renderFrame(visibleElements);\n  }\n  \n  // Method to seek to a specific time\n  seekToTime(time: number): void {\n    // Clamp time to valid range\n    const targetTime = Math.max(0, Math.min(time, this.totalDuration));\n    this.currentTime = targetTime;\n    \n    // Update the last render time to avoid large time jumps when animation resumes\n    this.lastRenderTime = performance.now();\n    \n    // Queue render at this time\n    this.queueRender();\n    \n    // If we seek to the end, make sure isPlaying is false\n    if (targetTime >= this.totalDuration) {\n      this.isPlaying = false;\n    }\n    \n    // Save the current state\n    this.savePlayerState();\n  }\n  \n  // Getter and setter for forceDefaultLayerOnly\n  setForceDefaultLayerOnly(value: boolean): void {\n    if (this.forceDefaultLayerOnly !== value) {\n      this.forceDefaultLayerOnly = value;\n\n      if (!this.forceDefaultLayerOnly) {\n        // Queue re-render to apply the change\n        this.queueRender();\n      }\n    }\n  }\n  \n  getForceDefaultLayerOnly(): boolean {\n    return this.forceDefaultLayerOnly;\n  }\n\n  // Core animation method - now updated to work with the timeline\n  animate(elements: DrawableElement[], options: AnimationOptions) {\n    // Get current time and calculate segment timing\n    const startTime = this.currentTime;\n    const delay = options.delay || 0;\n    const segmentStartTime = startTime + delay;\n    const duration = options.duration;\n\n    // Associate each element with this segment's start time\n    for (const element of elements) {\n      element.segmentStartTime = segmentStartTime;\n      this.registerElement(element);\n    }\n\n    // Create a new animation segment and add it to our timeline\n    const segment: AnimationSegment = {\n      startTime: segmentStartTime,\n      duration: duration,\n      elements: [...elements],\n      easing: options.easing || ((t) => t) // Default to linear easing if not provided\n    };\n\n    // Add this segment to our timeline\n    this.animationSegments.push(segment);\n\n    // Update total duration\n    this.totalDuration = Math.max(this.totalDuration, segmentStartTime + duration);\n\n    if (!options?.parallel) {\n      // Advance current time\n      this.currentTime = segmentStartTime + duration;\n    }\n  }\n\n  // We don't need the startAnimation method any more as we're using the timeline-based approach\n\n  private renderElement(element: DrawableElement, ctx: OffscreenCanvasRenderingContext2D, progress: number): void {\n    if (element.update) element.update(progress);\n    element.draw(ctx, progress, { layers: this.layerLookup });\n  }\n\n  private renderFrame(progressMap: Map<DrawableElement, number>): void {\n    // We'll render each layer to its respective WebGL pipeline, then combine them with alpha blending\n    const currentTime = this.currentTime;\n    \n    // First, render the default layer\n    const defaultCtx = this.defaultLayerCanvas.getContext('2d')!;\n    defaultCtx.clearRect(0, 0, this.defaultLayerCanvas.width, this.defaultLayerCanvas.height);\n    defaultCtx.save();\n    defaultCtx.translate(this.pan[0], this.pan[1]);\n    defaultCtx.scale(this.zoom, this.zoom);\n\n    Object.keys(this.layerInitialProperties).forEach((layerName: string) => {\n      // Restore initial properties before rendering if they were changed by an animation\n      const initialProps = this.layerInitialProperties[layerName];\n      if (initialProps) {\n        const layer = this.layerLookup[layerName];\n        // Restore all initial properties\n        Object.assign(layer, initialProps);\n      }\n    });\n\n    // Only render elements that should be visible at current time\n    for (const element of this.defaultLayerElements) {\n      // Skip elements that were added after the current time\n      if (element.segmentStartTime !== undefined && element.segmentStartTime > currentTime) {\n        continue;\n      }\n      \n      // Get the progress for this element, defaulting to 1.0 for already-completed elements\n      const elementProgress = progressMap.has(element) ? progressMap.get(element)! : 1.0;\n      this.renderElement(element, defaultCtx, elementProgress);\n    }\n    \n    // If forceDefaultLayerOnly is true, collect all elements from all layers and render them to default layer\n    for (const layerName in this.layerElements) {\n      const layer = this.layerLookup[layerName];\n      if (this.forceDefaultLayerOnly && !layer.renderWhenScrubbing) {\n        const elements = this.layerElements[layerName];\n        for (const element of elements) {\n          // Skip elements that were added after the current time\n          if (element.segmentStartTime !== undefined && element.segmentStartTime > currentTime) {\n            continue;\n          }\n\n          // Get the progress for this element, defaulting to 1.0 for already-completed elements\n          const elementProgress = progressMap.has(element) ? progressMap.get(element)! : 1.0;\n          this.renderElement(element, defaultCtx, elementProgress);\n        }\n      }\n    }\n\n    // Process the default layer with its shader pipeline - use cached texture\n    const defaultTexture = this.getTextureForCanvas(this.defaultLayerCanvas);\n    this.texturePipelineResult.stage.set({\n      u_texture: defaultTexture,\n      u_progress: 1.0 // Always use full blending\n    });\n    \n    // Render directly to the screen\n    this.texturePipelineResult.renderer.setRenderTarget(null);\n    \n    // Make sure scissor test is disabled for the default layer\n    const gl = this.texturePipelineResult.gl;\n    gl.disable(gl.SCISSOR_TEST);\n\n    this.texturePipelineResult.render();\n    \n    // Now render each additional layer in order, but only if not forcing default layer only\n    for (const layer of this.layers) {\n      if (!this.forceDefaultLayerOnly || layer.renderWhenScrubbing) {\n        const layerCanvas = this.layerCanvases[layer.name];\n        const ctx = layerCanvas.getContext('2d')!;\n        ctx.clearRect(0, 0, layerCanvas.width, layerCanvas.height);\n        ctx.save();\n        const zoom = this.zoom;\n        const pan = this.pan;\n\n        // Apply transformations based on whether this is a subview or not\n        const x = (layer.x ?? 0) * zoom + pan[0];\n        const y = (layer.y ?? 0) * zoom + pan[1];\n        const width = (layer.width ?? layerCanvas.width) * zoom;\n        const height = (layer.height ?? layerCanvas.height) * zoom;\n\n        // For non-subview mode, also adjust the viewport to scale the full texture into the target area\n        if (!layer.isSubview) {\n          const scaleX = width / (this.canvas.width);\n          const scaleY = height / (this.canvas.height);\n          ctx.translate(x, y);\n          ctx.scale(scaleX, scaleY);\n        } else {\n          ctx.translate(pan[0], pan[1]);\n          ctx.scale(zoom, zoom);\n        }\n\n        // Draw all elements assigned to this layer that should be visible\n        const elements = this.layerElements[layer.name];\n        for (const element of elements) {\n          // Skip elements that were added after the current time\n          if (element.segmentStartTime !== undefined && element.segmentStartTime > currentTime) {\n            continue;\n          }\n\n          // Get the progress for this element, defaulting to 1.0 for already-completed elements\n          const elementProgress = progressMap.has(element) ? progressMap.get(element)! : 1.0;\n          this.renderElement(element, ctx, elementProgress);\n        }\n        ctx.restore();\n\n        // Process with the layer's shader pipeline - use cached texture\n        const texture = this.getTextureForCanvas(layerCanvas);\n\n        // Enable blending for transparent layers\n        const gl = this.texturePipelineResult.gl;\n        gl.enable(gl.BLEND);\n        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\n        // The scissor test is used regardless of mode to limit where rendering happens\n        gl.enable(gl.SCISSOR_TEST);\n\n        if (layer.ignorePanZoom) {\n          gl.scissor(\n            (layer.x ?? 0),\n            (layer.y ?? 0),\n            layer.width ?? layerCanvas.width,\n            layer.height ?? layerCanvas.height,\n          )\n        } else {\n          gl.scissor(\n            x,\n            this.canvas.height - y - height, // WebGL has origin at bottom left\n            width,\n            height\n          );\n        }\n\n        layer.render(texture, 1.0); // Always use full blending\n\n        // Disable blending and scissor test after rendering\n        gl.disable(gl.BLEND);\n        gl.disable(gl.SCISSOR_TEST);\n      }\n    }\n    defaultCtx.restore();\n  }\n}\n","// Define easing functions\nexport type EasingFunction = (t: number) => number;\n\nexport const Easing = {\n  // Linear\n  linear: (t: number): number => t,\n\n  // Quadratic\n  easeInQuad: (t: number): number => t * t,\n  easeOutQuad: (t: number): number => t * (2 - t),\n  easeInOutQuad: (t: number): number => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,\n\n  // Cubic\n  easeInCubic: (t: number): number => t * t * t,\n  easeOutCubic: (t: number): number => (--t) * t * t + 1,\n  easeInOutCubic: (t: number): number => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,\n\n  // Quartic\n  easeInQuart: (t: number): number => t * t * t * t,\n  easeOutQuart: (t: number): number => 1 - (--t) * t * t * t,\n  easeInOutQuart: (t: number): number => t < 0.5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t,\n\n  // Quintic\n  easeInQuint: (t: number): number => t * t * t * t * t,\n  easeOutQuint: (t: number): number => 1 + (--t) * t * t * t * t,\n  easeInOutQuint: (t: number): number => t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t,\n\n  // Sinusoidal\n  easeInSine: (t: number): number => 1 - Math.cos(t * Math.PI / 2),\n  easeOutSine: (t: number): number => Math.sin(t * Math.PI / 2),\n  easeInOutSine: (t: number): number => -(Math.cos(Math.PI * t) - 1) / 2,\n\n  // Exponential\n  easeInExpo: (t: number): number => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),\n  easeOutExpo: (t: number): number => t === 1 ? 1 : 1 - Math.pow(2, -10 * t),\n  easeInOutExpo: (t: number): number =>\n    t === 0 ? 0 : t === 1 ? 1 : t < 0.5\n      ? Math.pow(2, 20 * t - 10) / 2\n      : (2 - Math.pow(2, -20 * t + 10)) / 2,\n\n  // Circular\n  easeInCirc: (t: number): number => 1 - Math.sqrt(1 - t * t),\n  easeOutCirc: (t: number): number => Math.sqrt(1 - (--t) * t),\n  easeInOutCirc: (t: number): number =>\n    t < 0.5\n      ? (1 - Math.sqrt(1 - Math.pow(2 * t, 2))) / 2\n      : (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2,\n\n  // Back (overshoots)\n  easeInBack: (t: number): number => {\n    const s = 1.70158;\n    return t * t * ((s + 1) * t - s);\n  },\n  easeOutBack: (t: number): number => {\n    const s = 1.70158;\n    return --t * t * ((s + 1) * t + s) + 1;\n  },\n  easeInOutBack: (t: number): number => {\n    const s = 1.70158 * 1.525;\n    if ((t *= 2) < 1) return 0.5 * (t * t * ((s + 1) * t - s));\n    return 0.5 * ((t -= 2) * t * ((s + 1) * t + s) + 2);\n  },\n\n  // Elastic (bounces like a spring)\n  easeInElastic: (t: number): number => {\n    if (t === 0) return 0;\n    if (t === 1) return 1;\n    const p = 0.3; // Period\n    const s = p / (2 * Math.PI) * Math.asin(1); // Amplitude\n    return -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));\n  },\n  easeOutElastic: (t: number): number => {\n    if (t === 0) return 0;\n    if (t === 1) return 1;\n    const p = 0.3; // Period\n    const s = p / (2 * Math.PI) * Math.asin(1); // Amplitude\n    return Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;\n  },\n  easeInOutElastic: (t: number): number => {\n    if (t === 0) return 0;\n    if ((t *= 2) === 2) return 1;\n    const p = 0.3 * 1.5; // Period\n    const s = p / (2 * Math.PI) * Math.asin(1); // Amplitude\n    if (t < 1) return -0.5 * (Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));\n    return Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;\n  },\n\n  // Bounce (decays bounces at the end)\n  // Note: easeInBounce and easeInOutBounce depend on easeOutBounce\n  easeOutBounce: (t: number): number => {\n    const n1 = 7.5625;\n    const d1 = 2.75;\n    if (t < 1 / d1) {\n      return n1 * t * t;\n    } else if (t < 2 / d1) {\n      return n1 * (t -= 1.5 / d1) * t + 0.75;\n    } else if (t < 2.5 / d1) {\n      return n1 * (t -= 2.25 / d1) * t + 0.9375;\n    } else {\n      return n1 * (t -= 2.625 / d1) * t + 0.984375;\n    }\n  },\n  easeInBounce: (t: number): number => {\n    // Need to reference easeOutBounce from the same object\n    // This assumes Easing.easeOutBounce is accessible\n    return 1 - Easing.easeOutBounce(1 - t);\n  },\n  easeInOutBounce: (t: number): number => {\n    // Need to reference easeOutBounce from the same object\n    // This assumes Easing.easeOutBounce is accessible\n    return t < 0.5\n      ? (1 - Easing.easeOutBounce(1 - 2 * t)) / 2\n      : (1 + Easing.easeOutBounce(2 * t - 1)) / 2;\n  },\n};","/**\n * Mation library loaders\n * This module provides functions to dynamically load external libraries needed by Mation\n */\n\n/**\n * Configuration options for library loading\n */\nexport interface LibraryConfig {\n  /** Base path to load libraries from, defaults to finding from the current script */\n  basePath?: string;\n}\n\n/**\n * Check if a script is already loaded\n */\nfunction isScriptLoaded(src: string): boolean {\n  return !!document.querySelector(`script[src*=\"${src}\"]`);\n}\n\n/**\n * Get the base path for loading libraries based on the current script\n */\nfunction getBasePath(): string {\n  // Try to find the path to the Mation script that's currently running\n  const scripts = Array.from(document.getElementsByTagName('script'));\n  const mationScript = scripts.find(script => \n    script.src && (script.src.includes('mation.js') || script.src.includes('mation.min.js'))\n  );\n\n  if (mationScript) {\n    // Extract the base path from the script URL\n    const scriptUrl = new URL(mationScript.src);\n    const pathParts = scriptUrl.pathname.split('/');\n    // Remove the filename to get the directory\n    pathParts.pop();\n    // Handle special case of serving from root\n    return pathParts.length === 0 ? '/' : `${scriptUrl.origin}${pathParts.join('/')}`;\n  }\n\n  // Fallback to the current location if we can't find the script\n  return window.location.origin;\n}\n\n/**\n * Load a script dynamically\n */\nasync function loadScript(src: string): Promise<void> {\n  if (isScriptLoaded(src)) {\n    return Promise.resolve();\n  }\n\n  return new Promise((resolve, reject) => {\n    const script = document.createElement('script');\n    script.src = src;\n    script.async = true;\n    script.onload = () => resolve();\n    script.onerror = (error) => reject(new Error(`Failed to load script: ${src}: ${error}`));\n    document.head.appendChild(script);\n  });\n}\n\n/**\n * Async function to load FFmpeg libraries\n */\nexport async function loadFFmpeg(config: LibraryConfig = {}): Promise<void> {\n  const basePath = config.basePath || getBasePath();\n  \n  try {\n    // Check if FFmpeg is already loaded\n    if ((window as any).ffmpegInitialized && (window as any).ffmpegInstance) {\n      return;\n    }\n\n    // Create a script tag to load the FFmpeg scripts properly\n    const ffmpegScript = document.createElement('script');\n    ffmpegScript.src = `${basePath}/libs/ffmpeg/ffmpeg.min.js`;\n    \n    await new Promise<void>((resolve, reject) => {\n      ffmpegScript.onload = async () => {\n        try {\n          // Create a new instance\n          const { FFmpeg } = (window as any).FFmpegWASM;\n          const ffmpeg = new FFmpeg();\n          \n          // Load the core\n          await ffmpeg.load({\n            coreURL: `${basePath}/libs/ffmpeg/ffmpeg-core.js`,\n            wasmURL: `${basePath}/libs/ffmpeg/ffmpeg-core.wasm`,\n          });\n          \n          // Store the initialized instance globally\n          (window as any).ffmpegInstance = ffmpeg;\n          (window as any).ffmpegInitialized = true;\n          \n          console.log('FFmpeg loaded successfully');\n          resolve();\n        } catch (err) {\n          reject(err);\n        }\n      };\n      \n      ffmpegScript.onerror = () => reject(new Error('Failed to load FFmpeg script'));\n      document.head.appendChild(ffmpegScript);\n    });\n  } catch (error) {\n    console.error('Failed to load FFmpeg:', error);\n    throw error;\n  }\n}\n\n/**\n * Async function to load JSZip library\n */\nexport async function loadJSZip(config: LibraryConfig = {}): Promise<void> {\n  const basePath = config.basePath || getBasePath();\n  \n  try {\n    await loadScript(`${basePath}/libs/jszip/jszip.min.js`);\n    console.log('JSZip loaded successfully');\n  } catch (error) {\n    console.error('Failed to load JSZip:', error);\n    throw error;\n  }\n}\n\n/**\n * Load all libraries required for rendering\n */\nexport async function loadRenderingLibraries(config: LibraryConfig = {}): Promise<void> {\n  try {\n    await Promise.all([\n      loadFFmpeg(config),\n      loadJSZip(config)\n    ]);\n    console.log('All rendering libraries loaded successfully');\n  } catch (error) {\n    console.error('Failed to load rendering libraries:', error);\n    throw error;\n  }\n}","import { IScene } from \"./animation.ts\";\nimport { loadRenderingLibraries, LibraryConfig } from \"./loaders.ts\";\n\nconst NODE_PORT = 3005;\n\n// FFmpeg will be loaded on demand when rendering is requested\n\n// Available output formats\nexport type OutputFormat = 'mp4' | 'zip' | 'node_mp4';\n\n// Check which render formats are available\nexport function getAvailableFormats(): OutputFormat[] {\n  const formats: OutputFormat[] = ['mp4', 'zip'];\n  \n  // Check if we have a server endpoint to render node_mp4\n  if (window.location.hostname === 'localhost' || \n      window.location.hostname === '127.0.0.1') {\n    formats.push('node_mp4');\n  }\n  \n  return formats;\n}\n\n// Render animation to MP4 video using ffmpeg-wasm\nexport async function renderToVideo(scene: IScene, options: {\n  framerate?: number;\n  codec?: string;\n  outputFile?: string;\n  duration?: number;\n  fps?: number;\n  onProgress?: (progress: number) => void;\n  outputFormat?: OutputFormat;\n  libraryConfig?: LibraryConfig;\n} = {}): Promise<void> {\n  // Load required libraries first\n  await loadRenderingLibraries(options.libraryConfig);\n  const {\n    framerate = 60,\n    codec = 'libx264',\n    outputFile = 'out.mp4',\n    onProgress,\n    outputFormat = 'mp4'\n  } = options;\n\n  // Calculate frame times based on duration and framerate\n  const totalDuration = scene.getDuration();\n  const frameTimes = [];\n\n  const timePerFrame = 1.0 / framerate;\n\n  for (let i = 0; i <= totalDuration + timePerFrame; i += timePerFrame) {\n    frameTimes.push(i);\n  }\n\n  // Pause any ongoing animation\n  const wasPlaying = scene.playing();\n  scene.pause();\n  scene.seekToTime(0);\n\n  const partial = 1.0 / frameTimes.length;\n  const frameBlobs: Blob[] = [];\n  const frameNames: string[] = [];\n\n  // For each frame time, render at that time and capture\n  for (let i = 0; i < frameTimes.length; i++) {\n    scene.renderAtTime(frameTimes[i]);\n    const blob: Blob = await new Promise((resolve) =>\n      scene.canvas.toBlob((blob) => {\n        resolve(blob as Blob);\n      })\n    );\n    \n    const frameName = `frame_${i.toString().padStart(6, '0')}.png`;\n    frameNames.push(frameName);\n    \n    if (outputFormat === 'mp4') {\n      const ffmpeg = (window as any).ffmpegInstance;\n      ffmpeg.writeFile(frameName, new Uint8Array(await blob.arrayBuffer()));\n    } else {\n      frameBlobs.push(blob);\n    }\n    \n    // Update progress (allocate up to 30% of progress bar to frame processing for mp4, 90% for zip)\n    if (onProgress) {\n      const progressMultiplier = outputFormat === 'mp4' ? 0.3 : 0.9;\n      onProgress((progressMultiplier * (i * partial)));\n    }\n  }\n\n  if (onProgress) onProgress(outputFormat === 'mp4' ? 0.3 : 0.9); // Frame capture completed\n\n  if (outputFormat === 'mp4') {\n    const ffmpeg = (window as any).ffmpegInstance;\n    \n    // Set up progress handler for ffmpeg\n    ffmpeg.on('progress', ({ progress }: { progress: number; time: number }) => {\n      if (onProgress) {\n        const mappedProgress = 0.3 + (progress * 0.7);\n        onProgress(mappedProgress);\n      }\n    });\n\n    ffmpeg.on('log', (log: any) => {\n      console.log(`ffmpeg log: ${JSON.stringify(log)}`);\n    });\n\n    // Run FFmpeg command to convert frames to video\n    await ffmpeg.exec([\n      '-framerate', String(framerate),\n      '-pattern_type', 'glob',\n      '-i', '*.png',\n      '-c:v', codec,\n      '-preset', 'medium',\n      '-pix_fmt', 'yuv420p',\n      '-crf', '18',\n      outputFile\n    ]);\n\n    if (onProgress) onProgress(0.9); // Video encoding completed\n\n    // Read the output file from the virtual filesystem\n    const data = await ffmpeg.readFile(outputFile) as Uint8Array;\n\n    // Create a download link for the video\n    const blob = new Blob([data.buffer], { type: 'video/mp4' });\n    const url = URL.createObjectURL(blob);\n    const link = document.createElement('a');\n    link.href = url;\n    link.download = outputFile;\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n\n    // Clean up\n    URL.revokeObjectURL(url);\n  } else if (outputFormat === 'node_mp4') {\n    // Server-side rendering using WebSockets for efficient binary transfer\n    const serverUrl = `ws://${window.location.hostname}:${NODE_PORT}`;\n    let socket: WebSocket;\n    \n    try {\n      // Connect to WebSocket server\n      socket = new WebSocket(serverUrl);\n      \n      // Set up event handlers\n      socket.onopen = function() {\n        if (onProgress) onProgress(0.1); // Connected to server\n        \n        // Initialize a new session\n        socket.send(JSON.stringify({\n          type: 'init',\n          metadata: {\n            framerate,\n            codec,\n            totalFrames: frameBlobs.length\n          }\n        }));\n      };\n      \n      socket.onmessage = async function(event) {\n        const message = JSON.parse(event.data);\n        \n        switch (message.type) {\n          case 'init':\n            // Session initialized, start sending frames\n            if (onProgress) onProgress(0.15);\n            await sendFrames(socket, frameBlobs);\n            break;\n            \n          case 'frame_received':\n            // Frame received confirmation\n            if (onProgress) {\n              // Allocate 70% of progress to frame uploads (from 0.15 to 0.85)\n              const uploadProgress = 0.15 + ((message.index + 1) / frameBlobs.length * 0.7);\n              onProgress(uploadProgress);\n            }\n            \n            // If this was the last frame, start rendering\n            if (message.index === frameBlobs.length - 1) {\n              socket.send(JSON.stringify({\n                type: 'render',\n                framerate,\n                codec\n              }));\n            }\n            break;\n            \n          case 'render_started':\n            if (onProgress) onProgress(0.85);\n            break;\n            \n          case 'progress':\n            if (onProgress) {\n              // Allocate remaining 15% to rendering progress\n              const renderProgress = 0.85 + ((message.frame / message.totalFrames) * 0.13);\n              onProgress(Math.min(renderProgress, 0.98));\n            }\n            break;\n            \n          case 'completed':\n            if (onProgress) onProgress(0.98);\n            \n            // Create download link\n            const url = `http://${window.location.hostname}:${NODE_PORT}${message.downloadUrl}`;\n            const link = document.createElement('a');\n            link.href = url;\n            link.download = outputFile;\n            document.body.appendChild(link);\n            link.click();\n            document.body.removeChild(link);\n            \n            if (onProgress) onProgress(1.0);\n            socket.close();\n            break;\n            \n          case 'error':\n            console.error('Server error:', message.message);\n            throw new Error(`Server error: ${message.message}`);\n        }\n      };\n      \n      socket.onerror = function(error) {\n        console.error('WebSocket error:', error);\n        throw new Error('WebSocket connection error');\n      };\n      \n      // Wait for the socket to close or error out\n      await new Promise((resolve, reject) => {\n        socket.onclose = resolve;\n        socket.onerror = reject;\n      });\n      \n    } catch (error) {\n      console.error('Error in node_mp4 rendering:', error);\n      // @ts-ignore\n      if (socket && socket.readyState === WebSocket.OPEN) {\n        socket.close();\n      }\n      throw error;\n    }\n  } else {\n    // Create a zip file with JSZip\n    const JSZip = (window as any).JSZip;\n    if (!JSZip) {\n      throw new Error('JSZip library is not loaded. Please include JSZip in your project.');\n    }\n    \n    const zip = new JSZip();\n    \n    // Add all frame PNGs to the zip\n    for (let i = 0; i < frameBlobs.length; i++) {\n      zip.file(frameNames[i], frameBlobs[i]);\n    }\n    \n    // Generate the zip file\n    const zipBlob = await zip.generateAsync({ type: 'blob' });\n    \n    // Create a download link for the zip\n    const url = URL.createObjectURL(zipBlob);\n    const link = document.createElement('a');\n    link.href = url;\n    link.download = outputFile.replace(/\\.\\w+$/, '') + '.zip';\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n    \n    // Clean up\n    URL.revokeObjectURL(url);\n  }\n  \n  // Helper function to send frames to the WebSocket server\n  async function sendFrames(socket: WebSocket, frames: Blob[]) {\n    for (let i = 0; i < frames.length; i++) {\n      // Wait for socket to be ready for sending\n      while (socket.bufferedAmount > 1024 * 1024) {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      }\n      \n      // Convert Blob to ArrayBuffer\n      const arrayBuffer = await frames[i].arrayBuffer();\n      \n      // Send the binary frame data\n      socket.send(arrayBuffer);\n      \n      // Small delay to prevent overwhelming the socket\n      if (i % 10 === 0) {\n        await new Promise(resolve => setTimeout(resolve, 10));\n      }\n    }\n  }\n\n  // Restore play state\n  if (wasPlaying) {\n    scene.play();\n  }\n\n  if (onProgress) onProgress(1); // Process completed\n}\n","/**\n * Mation CSS styles\n * This module contains the CSS styles for the Mation UI components\n */\n\nexport const styles = `\nbody {\n  margin: 0;\n  background: #181818;\n}\n\n/* Animation controls */\n.animation-controls {\n  position: absolute;\n  bottom: 120px;\n  left: 50%;\n  transform: translateX(-50%);\n  display: flex;\n  align-items: center;\n  background: rgba(34, 34, 34, 0.7);\n  padding: 10px;\n  border-radius: 4px;\n  width: 100%;\n  max-width: 500px;\n  z-index: 10;\n}\n\n.play-pause-button {\n  background: #333;\n  border: none;\n  color: white;\n  width: 40px;\n  height: 40px;\n  border-radius: 50%;\n  cursor: pointer;\n  margin-right: 10px;\n  font-size: 18px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.play-pause-button:hover {\n  background: #444;\n}\n\n/* Reset zoom button positioned at bottom left */\n.reset-zoom-button {\n  position: absolute;\n  bottom: 20px;\n  left: 20px;\n  background: rgba(34, 34, 34, 0.7);\n  border: none;\n  color: white;\n  width: 40px;\n  height: 40px;\n  border-radius: 50%;\n  cursor: pointer;\n  font-size: 18px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  z-index: 10;\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);\n}\n\n.reset-zoom-button:hover {\n  background: rgba(51, 51, 51, 0.9);\n}\n\n.scrubber-container {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n}\n\n.time-display {\n  color: white;\n  font-size: 12px;\n  margin-bottom: 5px;\n  font-family: monospace;\n}\n\n.scrubber {\n  width: 100%;\n  cursor: pointer;\n  height: 10px;\n  -webkit-appearance: none;\n  background: #333;\n  border-radius: 5px;\n  outline: none;\n}\n\n.scrubber::-webkit-slider-thumb {\n  -webkit-appearance: none;\n  appearance: none;\n  width: 16px;\n  height: 16px;\n  background: #3498db;\n  border-radius: 50%;\n  cursor: pointer;\n}\n\n.scrubber::-moz-range-thumb {\n  width: 16px;\n  height: 16px;\n  background: #3498db;\n  border-radius: 50%;\n  cursor: pointer;\n  border: none;\n}\n\n/* Render dropdown and button */\n.render-dropdown {\n  position: absolute;\n  bottom: 20px;\n  right: 20px;\n  z-index: 10;\n}\n\n.button-container {\n  display: flex;\n  border-radius: 4px;\n  overflow: hidden;\n}\n\n.render-button {\n  padding: 10px 20px;\n  background-color: #3498db;\n  color: white;\n  border: none;\n  border-radius: 4px 0 0 4px;\n  font-size: 16px;\n  cursor: pointer;\n  border-right: 1px solid rgba(255,255,255,0.2);\n}\n\n.render-button:hover {\n  background-color: #2980b9;\n}\n\n.render-button:disabled {\n  background-color: #666;\n  cursor: not-allowed;\n}\n\n.dropdown-toggle {\n  width: 30px;\n  background-color: #3498db;\n  color: white;\n  border: none;\n  border-radius: 0 4px 4px 0;\n  cursor: pointer;\n  font-size: 12px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.dropdown-toggle:hover {\n  background-color: #2980b9;\n}\n\n.render-options {\n  display: none;\n  position: absolute;\n  bottom: 45px;\n  right: 0;\n  width: 200px;\n  background-color: #2c2c2c;\n  border-radius: 4px;\n  box-shadow: 0 4px 12px rgba(0,0,0,0.3);\n  overflow: hidden;\n}\n\n.render-options.visible {\n  display: block;\n}\n\n.render-option {\n  padding: 12px 16px;\n  color: white;\n  cursor: pointer;\n  transition: background-color 0.2s;\n}\n\n.render-option:hover {\n  background-color: #3a3a3a;\n}\n\n.render-option.selected {\n  background-color: #1a1a1a;\n  position: relative;\n}\n\n.render-option.selected:after {\n  content: '✓';\n  position: absolute;\n  right: 16px;\n  top: 50%;\n  transform: translateY(-50%);\n  color: #3498db;\n}\n\n.progress-container {\n  position: absolute;\n  bottom: 70px;\n  right: 20px;\n  width: 200px;\n  height: 6px;\n  background-color: rgba(255, 255, 255, 0.2);\n  border-radius: 3px;\n  overflow: hidden;\n  z-index: 10;\n  opacity: 0;\n  transition: opacity 0.3s ease;\n}\n\n.progress-container.visible {\n  opacity: 1;\n}\n\n.progress-bar {\n  height: 100%;\n  width: 0%;\n  background-color: #3498db;\n  transition: width 0.1s linear;\n}\n`;\n\n/**\n * Inject the Mation styles into the document\n */\nexport function injectStyles() {\n  const styleEl = document.createElement('style');\n  styleEl.id = 'mation-styles';\n  styleEl.textContent = styles;\n  document.head.appendChild(styleEl);\n}\n\n/**\n * Remove the Mation styles from the document\n */\nexport function removeStyles() {\n  const styleEl = document.getElementById('mation-styles');\n  if (styleEl) {\n    styleEl.remove();\n  }\n}","import { IScene } from \"./animation.ts\";\nimport { renderToVideo, OutputFormat, getAvailableFormats } from \"./videoRenderer.ts\";\nimport { injectStyles, removeStyles } from \"./styles.ts\";\nimport { LibraryConfig } from \"./loaders.ts\";\n\n/**\n * Options for creating a new Mation instance\n */\nexport interface MationOptions {\n  /** Whether to enable rendering controls */\n  enableRendering?: boolean;\n  /** Whether to inject styles automatically */\n  injectStyles?: boolean;\n  /** \n   * Configuration for external libraries.\n   * By default, libraries are automatically loaded from the same location as the Mation script.\n   */\n  libraryConfig?: LibraryConfig;\n}\n\n/**\n * Mation - Main controller class for animation scenes\n * \n * This class provides the UI and controls for playing, pausing, scrubbing,\n * and rendering animations. It works with any class that implements the IScene\n * interface.\n */\nexport default class Mation {\n  scene?: IScene;\n  private playPauseButton: HTMLButtonElement | null = null;\n  private scrubber: HTMLInputElement | null = null;\n  private timeDisplay: HTMLElement | null = null;\n  private renderButton: HTMLButtonElement | null = null;\n  private renderDropdown: HTMLDivElement | null = null;\n  private renderOptions: HTMLDivElement | null = null;\n  private dropdownToggle: HTMLButtonElement | null = null;\n  private selectedFormat: OutputFormat = 'mp4';\n  private progressContainer: HTMLElement | null = null;\n  private progressBar: HTMLElement | null = null;\n  private isPlaying = true;\n  private isDragging = false;\n  private wasPlayingBeforeDrag = false;\n  private isRendering = false;\n  private options: MationOptions;\n\n  constructor(options: MationOptions = {}) {\n    this.options = {\n      enableRendering: true,\n      injectStyles: true,\n      ...options\n    };\n    \n    // Inject styles if requested\n    if (this.options.injectStyles) {\n      injectStyles();\n    }\n  }\n\n  /**\n   * Set the scene to be controlled by this Mation instance\n   * @param scene Any object implementing the IScene interface\n   */\n  setScene(scene: IScene) {\n    this.scene = scene;\n  }\n\n  setZoom(scene: IScene, zoom: number) {\n    scene.setZoom(zoom);\n  }\n\n  setPan(scene: IScene, pan: [number, number]) {\n    scene.setPan(pan);\n  }\n\n  getZoom(scene: IScene) {\n    return (scene as any).zoom;\n  }\n\n  getPan(scene: IScene) {\n    return (scene as any).pan;\n  }\n  \n  setTargetFPS(fps: number) {\n    if (this.scene) {\n      this.scene.setTargetFPS(fps);\n    }\n  }\n  \n  queueRender() {\n    if (this.scene) {\n      this.scene.queueRender();\n    }\n  }\n\n  async initialize(container: Element) {\n    // If we have a scene already, set up the canvas for it\n    if (!this.scene) {\n      throw Error(\"Can't initialize without a scene.\");\n    }\n\n    // Set up the UI controls\n    this.setupControls(container);\n    \n    // Run the animation sequence to build the timeline\n    if (this.scene) {\n      await this.scene.runSequence();\n      \n      // Initialize duration once animation is loaded\n      const duration = this.scene.getDuration();\n      const currentTime = this.scene.getCurrentTime();\n      \n      // Update time display with the current position\n      this.updateTimeDisplay(currentTime, duration);\n      \n      // Make sure isPlaying state is reflected in the button\n      this.isPlaying = this.scene.playing();\n      if (this.playPauseButton) {\n        this.playPauseButton.textContent = this.isPlaying ? '⏸️' : '▶️';\n      }\n    }\n    \n    // Start updating the scrubber\n    this.updateScrubber();\n    \n    // Expose for debugging\n    (window as any).mation = this;\n    (window as any).render = async (format: OutputFormat = 'mp4') => {\n      if (this.scene) {\n        await renderToVideo(this.scene, { \n          outputFormat: format,\n          libraryConfig: this.options.libraryConfig \n        });\n      } else {\n        console.error(\"No scene available to render\");\n      }\n    };\n    (window as any).setTargetFPS = (fps: number) => {\n      if (this.scene) {\n        this.scene.setTargetFPS(fps);\n        console.log(`Target FPS set to ${fps}`);\n      }\n    };\n  }\n  \n  /**\n   * Clean up and destroy the Mation instance\n   * Call this when you're done with the Mation instance to clean up resources\n   */\n  destroy() {\n    // Pause any ongoing animation\n    if (this.scene) {\n      this.scene.pause();\n    }\n    \n    // Remove styles if they were injected\n    if (this.options.injectStyles) {\n      removeStyles();\n    }\n    \n    // Remove global references\n    if ((window as any).mation === this) {\n      delete (window as any).mation;\n      delete (window as any).render;\n      delete (window as any).setTargetFPS;\n    }\n  }\n\n  private setupControls(container: Element) {\n    // Create animation controls\n    const controlsContainer = document.createElement('div');\n    controlsContainer.className = 'animation-controls';\n    container.appendChild(controlsContainer);\n    \n    // Play/Pause button\n    this.playPauseButton = document.createElement('button');\n    this.playPauseButton.className = 'play-pause-button';\n    this.playPauseButton.textContent = '⏸️';\n    controlsContainer.appendChild(this.playPauseButton);\n    \n    // Reset Zoom button (positioned at bottom left, outside player controls)\n    const resetZoomButton = document.createElement('button');\n    resetZoomButton.className = 'reset-zoom-button';\n    resetZoomButton.textContent = '🔍';\n    resetZoomButton.title = 'Reset Zoom';\n    container.appendChild(resetZoomButton);\n    \n    // Scrubber/slider container\n    const scrubberContainer = document.createElement('div');\n    scrubberContainer.className = 'scrubber-container';\n    controlsContainer.appendChild(scrubberContainer);\n    \n    // Time display\n    this.timeDisplay = document.createElement('div');\n    this.timeDisplay.className = 'time-display';\n    this.timeDisplay.textContent = '0.00 / 0.00';\n    scrubberContainer.appendChild(this.timeDisplay);\n    \n    // Scrubber input\n    this.scrubber = document.createElement('input');\n    this.scrubber.type = 'range';\n    this.scrubber.min = '0';\n    this.scrubber.max = '1000'; // We'll use 1000 steps for precision\n    this.scrubber.value = '0';\n    this.scrubber.className = 'scrubber';\n    scrubberContainer.appendChild(this.scrubber);\n    \n    // Only add rendering controls if enabled\n    if (this.options.enableRendering) {\n      // Create render dropdown container\n      this.renderDropdown = document.createElement('div');\n      this.renderDropdown.className = 'render-dropdown';\n      container.appendChild(this.renderDropdown);\n      \n      // Create button container (holds both buttons)\n      const buttonContainer = document.createElement('div');\n      buttonContainer.className = 'button-container';\n      this.renderDropdown.appendChild(buttonContainer);\n      \n      // Create and add render button\n      this.renderButton = document.createElement('button');\n      this.renderButton.className = 'render-button';\n      this.renderButton.textContent = 'Render MP4';\n      buttonContainer.appendChild(this.renderButton);\n      \n      // Create dropdown toggle button\n      this.dropdownToggle = document.createElement('button');\n      this.dropdownToggle.className = 'dropdown-toggle';\n      this.dropdownToggle.innerHTML = '▼';\n      buttonContainer.appendChild(this.dropdownToggle);\n      \n      // Create render options dropdown\n      this.renderOptions = document.createElement('div');\n      this.renderOptions.className = 'render-options';\n      this.renderDropdown.appendChild(this.renderOptions);\n      \n      // Get available formats\n      const availableFormats = getAvailableFormats();\n      \n      // Add MP4 option\n      const mp4Option = document.createElement('div');\n      mp4Option.className = 'render-option selected';\n      mp4Option.textContent = 'MP4 Video';\n      mp4Option.dataset.format = 'mp4';\n      this.renderOptions.appendChild(mp4Option);\n      \n      // Add ZIP option\n      const zipOption = document.createElement('div');\n      zipOption.className = 'render-option';\n      zipOption.textContent = 'PNG Sequence (ZIP)';\n      zipOption.dataset.format = 'zip';\n      this.renderOptions.appendChild(zipOption);\n      \n      // Add Node MP4 option if available\n      if (availableFormats.includes('node_mp4')) {\n        const nodeOption = document.createElement('div');\n        nodeOption.className = 'render-option';\n        nodeOption.textContent = 'Server MP4 (faster)';\n        nodeOption.dataset.format = 'node_mp4';\n        this.renderOptions.appendChild(nodeOption);\n      }\n      \n      // Create progress container\n      this.progressContainer = document.createElement('div');\n      this.progressContainer.className = 'progress-container';\n      container.appendChild(this.progressContainer);\n      \n      this.progressBar = document.createElement('div');\n      this.progressBar.className = 'progress-bar';\n      this.progressContainer.appendChild(this.progressBar);\n    }\n    \n    // Set up event listeners\n    this.setupEventListeners();\n  }\n\n  private setupEventListeners() {\n    // Play/Pause button handler\n    this.playPauseButton?.addEventListener('click', () => {\n      if (!this.scene) return;\n      \n      if (this.isPlaying) {\n        // Pause the animation\n        this.scene.pause();\n        if (this.playPauseButton) this.playPauseButton.textContent = '▶️';\n      } else {\n        // If we're at the end of the animation, restart from beginning\n        if (this.scene.getCurrentTime() >= this.scene.getDuration()) {\n          this.scene.seekToTime(0);\n        }\n        // Play the animation\n        this.scene.play();\n        if (this.playPauseButton) this.playPauseButton.textContent = '⏸️';\n      }\n      this.isPlaying = !this.isPlaying;\n    });\n    \n    // Reset zoom button handler\n    const resetZoomButton = document.querySelector('.reset-zoom-button');\n    resetZoomButton?.addEventListener('click', () => {\n      if (!this.scene) return;\n      \n      // Reset to center of canvas\n      const canvasWidth = this.scene.canvas.width;\n      const canvasHeight = this.scene.canvas.height;\n      this.scene.setMousePosition(canvasWidth / 2, canvasHeight / 2);\n      \n      // Reset zoom to 1.0\n      this.scene.setZoom(1.0);\n      \n      // Reset pan to [0, 0]\n      this.scene.setPan([0, 0]);\n    });\n\n    // Scrubber handlers\n    this.scrubber?.addEventListener('mousedown', () => {\n      if (!this.scene) return;\n      this.isDragging = true;\n      this.wasPlayingBeforeDrag = this.isPlaying;\n      this.scene.pause();\n      \n      // Enable default layer only mode while dragging\n      this.scene.setForceDefaultLayerOnly(true);\n    });\n\n    this.scrubber?.addEventListener('touchstart', () => {\n      if (!this.scene) return;\n      this.isDragging = true;\n      this.wasPlayingBeforeDrag = this.isPlaying;\n      this.scene.pause();\n      \n      // Enable default layer only mode while dragging\n      this.scene.setForceDefaultLayerOnly(true);\n    });\n\n    // These must remain on document to catch events outside the canvas\n    document.addEventListener('mouseup', () => {\n      if (!this.scene) return;\n      if (this.isDragging) {\n        this.isDragging = false;\n\n        // Disable default layer only mode when done dragging\n        this.scene.setForceDefaultLayerOnly(false);\n\n        if (this.wasPlayingBeforeDrag) {\n          this.scene.play();\n          this.isPlaying = true;\n          if (this.playPauseButton) this.playPauseButton.textContent = '⏸️';\n        }\n      }\n    });\n\n    document.addEventListener('touchend', () => {\n      if (!this.scene) return;\n      if (this.isDragging) {\n        this.isDragging = false;\n        \n        // Disable default layer only mode when done dragging\n        this.scene.setForceDefaultLayerOnly(false);\n\n        if (this.wasPlayingBeforeDrag) {\n          this.scene.play();\n          this.isPlaying = true;\n          if (this.playPauseButton) this.playPauseButton.textContent = '⏸️';\n        }\n      }\n    });\n\n    this.scrubber?.addEventListener('input', () => {\n      if (!this.scene || !this.scrubber) return;\n      const value = parseInt(this.scrubber.value, 10);\n      const duration = this.scene.getDuration();\n      const targetTime = (value / 1000) * duration;\n      this.scene.seekToTime(targetTime);\n      this.updateTimeDisplay(targetTime, duration);\n    });\n    \n    // Track mouse position for zooming\n    this.scene?.canvas?.addEventListener('mousemove', (event) => {\n      if (!this.scene || !this.scene.canvas) return;\n      \n      // Get mouse position relative to canvas\n      const rect = this.scene.canvas.getBoundingClientRect();\n      const x = event.clientX - rect.left;\n      const y = event.clientY - rect.top;\n\n      // Update the mouse position in the scene\n      this.scene.setMousePosition(x, y);\n    });\n\n    // Zoom with mouse wheel\n    let wheelTimeout: number | null = null;\n    \n    this.scene?.canvas?.addEventListener('wheel', (event) => {\n      if (!this.scene) return;\n\n      // Prevent default behavior to avoid page scrolling\n      event.preventDefault();\n\n      // Get mouse position relative to canvas\n      const rect = this.scene.canvas.getBoundingClientRect();\n      const x = event.clientX - rect.left;\n      const y = event.clientY - rect.top;\n\n      // First, update the mouse position\n      this.scene.setMousePosition(x, y);\n\n      // Get current zoom\n      const currentZoom = this.scene.zoom;\n\n      // Calculate new zoom based on wheel direction\n      let newZoom;\n      if (event.deltaY > 0) {\n        // Zoom out - use smaller steps for smoother experience\n        newZoom = Math.max(0.05, currentZoom / 1.1);\n      } else {\n        // Zoom in - use smaller steps for smoother experience\n        newZoom = Math.min(10, currentZoom * 1.1);\n      }\n\n      // Apply the new zoom - this will use queueRender internally\n      this.scene.setZoom(newZoom);\n      \n      // Enable force default layer only while zooming\n      this.scene.setForceDefaultLayerOnly(true);\n      \n      // Clear any existing timeout\n      if (wheelTimeout !== null) {\n        clearTimeout(wheelTimeout);\n      }\n      \n      // Set a new timeout to detect when zooming stops\n      wheelTimeout = window.setTimeout(() => {\n        // Set force default layer to false when zooming stops\n        if (this.scene) {\n          this.scene.setForceDefaultLayerOnly(false);\n        }\n        wheelTimeout = null;\n      }, 200); // 200ms debounce time\n    }, { passive: false });\n    \n    // Pan with Alt + mouse drag\n    let isPanning = false;\n    let lastX = 0;\n    let lastY = 0;\n\n    this.scene?.canvas?.addEventListener('mousedown', (event) => {\n      if (!this.scene) return;\n\n      // Only start panning if Alt key is pressed\n      if (event.altKey) {\n        isPanning = true;\n        lastX = event.clientX;\n        lastY = event.clientY;\n      }\n    });\n\n    this.scene?.canvas?.addEventListener('mousemove', (event) => {\n      if (!this.scene || !isPanning) return;\n      \n      const deltaX = event.clientX - lastX;\n      const deltaY = event.clientY - lastY;\n      \n      // Update pan values - this will use queueRender internally\n      const [currentX, currentY] = this.scene.pan;\n      this.scene.setPan([currentX + deltaX, currentY + deltaY]);\n\n      lastX = event.clientX;\n      lastY = event.clientY;\n    });\n    \n    this.scene?.canvas?.addEventListener('mouseup', () => {\n      isPanning = false;\n      this.scene?.setForceDefaultLayerOnly(false);\n    });\n    \n    // Touch-based panning with two fingers\n    let touchStartDistance = 0;\n    let initialZoom = 1;\n    let touchStartX = 0;\n    let touchStartY = 0;\n    \n    this.scene?.canvas?.addEventListener('touchstart', (event) => {\n      if (!this.scene) return;\n      \n      if (event.touches.length === 2) {\n        // Two-finger gesture started - handle zoom and pan\n        const touch1 = event.touches[0];\n        const touch2 = event.touches[1];\n        \n        // Calculate distance between touches for zoom\n        touchStartDistance = Math.hypot(\n          touch2.clientX - touch1.clientX,\n          touch2.clientY - touch1.clientY\n        );\n        \n        initialZoom = this.scene.zoom;\n        \n        // Calculate midpoint for pan\n        touchStartX = (touch1.clientX + touch2.clientX) / 2;\n        touchStartY = (touch1.clientY + touch2.clientY) / 2;\n      }\n    });\n    \n    this.scene?.canvas?.addEventListener('touchmove', (event) => {\n      if (!this.scene) return;\n      \n      if (event.touches.length === 2) {\n        // Prevent default to avoid page gestures\n        event.preventDefault();\n        \n        const touch1 = event.touches[0];\n        const touch2 = event.touches[1];\n        \n        // Handle zoom - calculate new distance\n        const currentDistance = Math.hypot(\n          touch2.clientX - touch1.clientX,\n          touch2.clientY - touch1.clientY\n        );\n        \n        // Calculate midpoint for zoom center\n        const currentMidX = (touch1.clientX + touch2.clientX) / 2;\n        const currentMidY = (touch1.clientY + touch2.clientY) / 2;\n        \n        // Get canvas position\n        const rect = this.scene.canvas.getBoundingClientRect();\n        const canvasX = currentMidX - rect.left;\n        const canvasY = currentMidY - rect.top;\n        \n        // Update mouse position for zoom centering\n        this.scene.setMousePosition(canvasX, canvasY);\n        \n        // Calculate zoom ratio\n        const zoomDelta = currentDistance / touchStartDistance;\n        this.scene.setZoom(initialZoom * zoomDelta);\n        \n        // Handle pan - calculate midpoint movement\n        const deltaX = currentMidX - touchStartX;\n        const deltaY = currentMidY - touchStartY;\n        \n        const [startX, startY] = this.scene.pan;\n        this.scene.setPan([startX + deltaX, startY + deltaY]);\n        \n        // Update start position for next move\n        touchStartX = currentMidX;\n        touchStartY = currentMidY;\n      }\n    }, { passive: false });\n\n    // Only set up rendering-related event listeners if rendering is enabled\n    if (this.options.enableRendering) {\n      // Dropdown toggle button\n      this.dropdownToggle?.addEventListener('click', () => {\n        if (this.isRendering) return;\n        \n        if (this.renderOptions) {\n          this.renderOptions.classList.toggle('visible');\n        }\n      });\n      \n      // Render option selection\n      this.renderOptions?.addEventListener('click', (event) => {\n        const target = event.target as HTMLElement;\n        if (target.classList.contains('render-option')) {\n          // Update selected format\n          const format = target.dataset.format as OutputFormat;\n          this.selectedFormat = format;\n          \n          // Update UI\n          const options = this.renderOptions?.querySelectorAll('.render-option');\n          options?.forEach(option => option.classList.remove('selected'));\n          target.classList.add('selected');\n          \n          // Update button text\n          if (this.renderButton) {\n            if (format === 'mp4') {\n              this.renderButton.textContent = 'Render MP4';\n            } else if (format === 'zip') {\n              this.renderButton.textContent = 'Render PNGs';\n            } else if (format === 'node_mp4') {\n              this.renderButton.textContent = 'Render Server MP4';\n            }\n          }\n          \n          // Hide dropdown\n          this.renderOptions?.classList.remove('visible');\n        }\n      });\n      \n      // Close dropdown when clicking elsewhere\n      document.addEventListener('click', (event) => {\n        if (this.renderOptions?.classList.contains('visible') && \n            this.dropdownToggle && \n            !(event.target === this.dropdownToggle || this.dropdownToggle.contains(event.target as Node)) &&\n            !(event.target === this.renderOptions || this.renderOptions.contains(event.target as Node))) {\n          this.renderOptions.classList.remove('visible');\n        }\n      });\n      \n      // Start rendering with main button\n      this.renderButton?.addEventListener('click', async () => {\n        if (!this.scene || this.isRendering || !this.renderButton || !this.progressContainer || !this.progressBar) return;\n\n        // Hide dropdown if visible\n        if (this.renderOptions?.classList.contains('visible')) {\n          this.renderOptions.classList.remove('visible');\n        }\n\n        this.isRendering = true;\n        this.renderButton.disabled = true;\n        this.renderButton.textContent = 'Rendering...';\n        this.progressContainer.classList.add('visible');\n        this.progressBar.style.width = '0%';\n\n        try {\n          await renderToVideo(this.scene, {\n            onProgress: (progress) => {\n              if (this.progressBar) this.progressBar.style.width = `${progress * 100}%`;\n            },\n            outputFormat: this.selectedFormat,\n            libraryConfig: this.options.libraryConfig\n          });\n\n          // Success\n          if (this.renderButton) this.renderButton.textContent = 'Render Complete!';\n          setTimeout(() => {\n            if (this.renderButton) {\n              if (this.selectedFormat === 'mp4') {\n                this.renderButton.textContent = 'Render MP4';\n              } else if (this.selectedFormat === 'zip') {\n                this.renderButton.textContent = 'Render PNGs';\n              } else if (this.selectedFormat === 'node_mp4') {\n                this.renderButton.textContent = 'Render Server MP4';\n              }\n              this.renderButton.disabled = false;\n            }\n            if (this.progressContainer) this.progressContainer.classList.remove('visible');\n          }, 3000);\n        } catch (error) {\n          console.error('Rendering failed:', error);\n          if (this.renderButton) this.renderButton.textContent = 'Render Failed';\n          setTimeout(() => {\n            if (this.renderButton) {\n              if (this.selectedFormat === 'mp4') {\n                this.renderButton.textContent = 'Render MP4';\n              } else if (this.selectedFormat === 'zip') {\n                this.renderButton.textContent = 'Render PNGs';\n              } else if (this.selectedFormat === 'node_mp4') {\n                this.renderButton.textContent = 'Render Server MP4';\n              }\n              this.renderButton.disabled = false;\n            }\n            if (this.progressContainer) this.progressContainer.classList.remove('visible');\n          }, 3000);\n        }\n\n        this.isRendering = false;\n      });\n    }\n  }\n\n  private updateTimeDisplay(currentTime: number, totalDuration: number) {\n    if (this.timeDisplay) {\n      this.timeDisplay.textContent = `${currentTime.toFixed(2)}s / ${totalDuration.toFixed(2)}s`;\n    }\n  }\n\n  private updateScrubber = () => {\n    // Only update scrubber if we're not actively dragging it\n    if (!this.isDragging && this.scrubber && this.scene) {\n      const currentTime = this.scene.getCurrentTime();\n      const totalDuration = this.scene.getDuration();\n\n      if (totalDuration > 0) {\n        // Update scrubber position\n        const value = Math.min(Math.floor((currentTime / totalDuration) * 1000), 1000);\n        this.scrubber.value = value.toString();\n\n        // Update time display\n        this.updateTimeDisplay(currentTime, totalDuration);\n\n        // Check if animation has ended\n        if (currentTime >= totalDuration && this.isPlaying) {\n          this.isPlaying = false;\n          if (this.playPauseButton) this.playPauseButton.textContent = '▶️';\n        }\n      }\n    }\n\n    requestAnimationFrame(this.updateScrubber);\n  }\n}"],"names":["prefix","vertexShaderDefault","Pass","w","quad","materialProperties","__publicField","fragmentShader","vertexShader","uniforms","name","updates","key","options","WebGLPipeline","renderTargetOverrides","extra","dpr","scale","canvas","width","height","renderTargetProps","renderTargetCount","renderTargets","i","pass","passName","RenderTarget","gl","texture","framebuffer","minFilter","magFilter","WebGL2MicroLayer","canvasScale","vertexShaderSource","fragmentShaderSource","program","source","line","index","type","shader","path","cb","image","self","tempCanvas","tempCtx","overrides","internalFormat","format","renderTargetName","status","target","renderTarget","textureUnits","numUniforms","value","location","uniformInfo","info","size","ensureTypedArray","arr","Type","textureUnit","programName","attributes","buffer","fullscreenQuad","buildWebGlPipeline","Layer","pipeline","render","defaultShader","_Scene","now","elapsed","deltaTime","prevTime","ctx","texturePipelineResult","defaultLayerCanvas","x","y","mouseX","mouseY","worldX","worldY","newPanX","newPanY","drawingCanvas","defaultPipeline","layer","layerName","element","canvasKey","state","e","savedState","fn","oldDuration","oldTime","wasPlaying","tempCurrentTime","timeToRestore","sequence","result","fps","time","targetTime","visibleSegments","segment","a","b","visibleElements","segmentElapsedTime","progress","elements","startTime","delay","segmentStartTime","duration","t","progressMap","currentTime","defaultCtx","initialProps","elementProgress","defaultTexture","layerCanvas","zoom","pan","scaleX","scaleY","Scene","Easing","s","p","isScriptLoaded","src","getBasePath","mationScript","script","scriptUrl","pathParts","loadScript","resolve","reject","error","loadFFmpeg","config","basePath","ffmpegScript","FFmpeg","ffmpeg","err","loadJSZip","loadRenderingLibraries","NODE_PORT","getAvailableFormats","formats","renderToVideo","scene","framerate","codec","outputFile","onProgress","outputFormat","totalDuration","frameTimes","timePerFrame","partial","frameBlobs","frameNames","blob","frameName","mappedProgress","log","data","url","link","serverUrl","socket","event","message","sendFrames","uploadProgress","renderProgress","JSZip","zip","zipBlob","frames","arrayBuffer","styles","injectStyles","styleEl","removeStyles","Mation","container","controlsContainer","resetZoomButton","scrubberContainer","buttonContainer","availableFormats","mp4Option","zipOption","nodeOption","_a","_b","_c","_d","_e","_f","_g","_h","_i","_j","_k","_l","_m","_n","_o","_p","_q","_r","_s","_t","_u","canvasWidth","canvasHeight","rect","wheelTimeout","currentZoom","newZoom","isPanning","lastX","lastY","deltaX","deltaY","currentX","currentY","touchStartDistance","initialZoom","touchStartX","touchStartY","touch1","touch2","currentDistance","currentMidX","currentMidY","canvasX","canvasY","zoomDelta","startX","startY","option"],"mappings":"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"}