<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D Animation</title>
  <script type="module" src="../mation.js"></script>
</head>
<body>
<div id="preview"></div>
<div id="svgs" style="display: none">
</div>

<script type="module">
  import { Mation, Scene, createPipeline, Easing, Layer } from '../mation.js';

  export class My3DScene extends Scene {
    setupLayers() {
      // Create 3D scene layer with its own pipeline
      const scenePipeline = createPipeline(this.canvas);
      const resolution = [this.width, this.height];
      // Create seed render pass for JFA
      const {
        render: seedRender, renderTargets: seedRenderTargets
      } = scenePipeline.add({
        fragmentShader: `
        uniform sampler2D surfaceTexture;
        uniform vec2 resolution;
        out vec4 FragColor;

        in vec2 vUv;

        void main() {
          // Get the hit position from the scene texture
          vec4 hitPos = texelFetch(surfaceTexture, ivec2(gl_FragCoord.x, gl_FragCoord.y), 0);
          
          // If we have a valid hit (w > 0), pass it through as a seed for JFA
          // Otherwise, clear it
          if (hitPos.w > 0.0) {
            FragColor = hitPos; // Pass through the hit position
          } else {
            FragColor = vec4(0.0, 0.0, 0.0, 0.0); // No hit
          }
        }`,
        uniforms: {
          resolution,
          surfaceTexture: null,
        }
      }, {
        internalFormat: scenePipeline.gl().RGBA32F,
        format: scenePipeline.gl().RGBA,
        type: scenePipeline.gl().FLOAT,
      });

      const passes = Math.ceil(Math.log2(Math.max(this.width, this.height))) - 1;
      const {
        render: jfaRender, renderTargets: jfaRenderTargets, uniforms: jfaUniforms,
      } = scenePipeline.add({
        fragmentShader: `
uniform vec2 oneOverSize;
uniform vec2 resolution;
uniform sampler2D inputTexture;
uniform float uOffset;
uniform int direction;
uniform bool skip;
uniform int passes;

const int MAX_TILE_SIZE = 32;

const float SQRT_2 = 1.41;

in vec2 vUv;
out vec4 FragColor;

void main() {
  if (skip) {
    FragColor = vec4(vUv, 0.0, 1.0);
  } else {
    vec4 nearestSeed = vec4(-1.0);
    float nearestDist = 999999.9;
    vec2 pre = uOffset * oneOverSize;

    // Start with the center to try to appeal to loading in a block
    vec2 sampleUV = vUv;

    // Check if the sample is within bounds
    vec4 sampleValue = texture(inputTexture, sampleUV);
    vec3 samplePos = sampleValue.xyz;

    if (sampleValue.w > 0.0) {
      float dist = length(samplePos - vec3(vUv, 0.0)) * 10.0; // Scale for better visualization
      if (dist < nearestDist) {
        nearestDist = dist;
        nearestSeed = sampleValue;
      }
    }

    float x = 0.0;
    float y = 0.0;
    float z = 0.0;

    for (float i = -1.0; i <= 1.0; i += 1.0) {
      if (direction == 0) {
        x = i;
      } else if (direction == 1) {
        y = i;
      } else {
        z = i;
      }
      if (x == 0.0 && y == 0.0 && z == 0.0) { continue; }
      vec2 sampleUV = vUv + vec2(x, y) * pre;

      // Check if the sample is within bounds
      if (sampleUV.x < 0.0 || sampleUV.x > 1.0 || sampleUV.y < 0.0 || sampleUV.y > 1.0) { continue; }

      vec4 sampleValue = texture(inputTexture, sampleUV);
      
      if (sampleValue.w > 0.0) {
        float dist = length(sampleValue.xyz - vec3(vUv, 0.0)) * 10.0; // Scale for better visualization
        if (dist < nearestDist) {
          nearestDist = dist;
          nearestSeed = sampleValue;
        }
      }
    }

    FragColor = nearestSeed;
  }
}`,
        uniforms: {
          inputTexture: null,
          resolution: [this.width, this.height],
          oneOverSize: [1.0 / this.width, 1.0 / this.height],
          uOffset: Math.pow(2, passes - 1),
          direction: 0,
          passes: passes,
          skip: true,
        }
      }, {
        internalFormat: scenePipeline.gl().RGBA32F,
        format: scenePipeline.gl().RGBA,
        type: scenePipeline.gl().FLOAT,
      });
      
      const {render: dfRender, renderTargets: dfRenderTargets} = scenePipeline.add({
        uniforms: {
          resolution: [this.width, this.height],
          jfaTexture: null,
        },
        fragmentShader: `
        uniform sampler2D jfaTexture;
        uniform vec2 resolution;

        in vec2 vUv;
        out vec4 FragColor;

        void main() {
          ivec2 texel = ivec2(vUv.x * resolution.x, vUv.y * resolution.y);
          vec4 nearestSeed = texelFetch(jfaTexture, texel, 0);
          
          if (nearestSeed.w <= 0.0) {
            FragColor = vec4(1.0, 0.0, 0.0, 1.0); // Far away / no hit
            return;
          }
          
          // Calculate distance in 3D
          float dist = clamp(length(nearestSeed.xyz - vec3(vUv, 0.0)) * 5.0, 0.0, 1.0);

          // Normalize and visualize the distance
          FragColor = vec4(dist, 0.0, 0.0, 1.0);
        }`,
      });

      const {uniforms: sceneUniforms, render: giRender, renderTargets: giRenderTargets} = scenePipeline.add({
        uniforms: {
          resolution: [this.width, this.height],
          oneOverSize: [1.0 / this.width, 1.0 / this.height],
          sceneTexture: null,
          distanceTexture: null,
          rayCount: 8,
          maxSteps: 120,
          sunAngle: 0.4,
          enableSun: true,
          showGrain: false,
          showNoise: true,
        },
        fragmentShader: `
uniform int rayCount;
uniform float sunAngle;
uniform bool showNoise;
uniform bool showGrain;
uniform bool enableSun;
uniform vec2 oneOverSize;
uniform int maxSteps;

uniform sampler2D sceneTexture;
uniform sampler2D distanceTexture;

out vec4 FragColor;
in vec2 vUv;

const float PI = 3.14159265;
const float TAU = 2.0 * PI;
const float ONE_OVER_TAU = 1.0 / TAU;
const float PAD_ANGLE = 0.01;
const float EPS = 0.001f;

const vec3 skyColor = vec3(0.02, 0.08, 0.2);
const vec3 sunColor = vec3(0.95, 0.95, 0.9);
const float goldenAngle = PI * 0.7639320225;

// Popular rand function
float rand(vec3 co) {
    return fract(sin(dot(co.xyz, vec3(12.9898, 78.233, 45.164))) * 43758.5453);
}

vec3 sunAndSky(float rayAngle) {
    // Get the sun / ray relative angle
    float angleToSun = mod(rayAngle - sunAngle, TAU);

    // Sun falloff based on the angle
    float sunIntensity = smoothstep(1.0, 0.0, angleToSun);

    // And that's our sky radiance
    return sunColor * sunIntensity + skyColor;
}

bool outOfBounds(vec2 uv) {
    return uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0;
}

vec3 getDirection(float angle, float z) {
    return normalize(vec3(cos(angle), z, sin(angle)));
}

void main() {
    vec2 uv = vUv;

    vec4 objectInfo = texture(sceneTexture, uv);
    vec4 radiance = vec4(0.0);

    float oneOverRayCount = 1.0 / float(rayCount);
    float angleStepSize = TAU * oneOverRayCount;

    float coef = 0.0;
    float offset = showNoise ? rand(vec3(uv, coef)) : 0.0;
    float rayAngleStepSize = showGrain ? angleStepSize + offset * TAU : angleStepSize;
    float minStepSize = min(oneOverSize.x, oneOverSize.y);

    // Not a hit in the scene
    if (objectInfo.w < 0.1) {
        // Sky color
        FragColor = vec4(skyColor * 0.5, 1.0); 
    }
    // Object hit
    else {
        // For 3D global illumination, we shoot rays in all directions
        for(int i = 0; i < rayCount; i++) {
            // Create semi-random ray angles for both theta (around) and phi (up/down)
            float theta = rayAngleStepSize * (float(i) + offset);
            float phi = rayAngleStepSize * (float(i) / 2.0 + offset) - PI/4.0; // Angled slightly upward
            
            vec3 rayDir = vec3(
                cos(theta) * cos(phi),
                sin(phi),
                sin(theta) * cos(phi)
            );
            
            vec2 sampleUv = uv;
            vec4 radDelta = vec4(0.0);
            bool hitSurface = false;

            // Ray marching in 2D space (conceptually 3D)
            for (int step = 1; step < maxSteps; step++) {
                // How far away is the nearest object?
                float dist = texture(distanceTexture, sampleUv).r;

                // Take a step in the 2D projection of our 3D ray direction
                sampleUv += vec2(rayDir.x, rayDir.z) * dist * 0.1;

                if (outOfBounds(sampleUv)) break;

                if (dist <= minStepSize) {
                    vec4 sampleColor = texture(sceneTexture, sampleUv);
                    if (sampleColor.w > 0.1) {
                        radDelta = sampleColor;
                        hitSurface = true;
                        break;
                    }
                }
            }

            // If we didn't find an object, add some sky + sun color
            if (!hitSurface && enableSun) {
                float skyIntensity = 0.5 + 0.5 * rayDir.y; // Brighten toward the top
                radDelta += vec4(skyColor * skyIntensity + sunColor * pow(max(0.0, dot(rayDir, normalize(vec3(cos(sunAngle), 0.5, sin(sunAngle))))), 32.0), 1.0);
            }

            // Accumulate total radiance
            radiance += radDelta;
        }
    
        // If it's a surface with color
        vec4 surfaceColor = objectInfo;
        
        // Apply global illumination
        vec4 finalRadiance = vec4(mix(surfaceColor.rgb, radiance.rgb * oneOverRayCount, 0.6), 1.0);
        FragColor = finalRadiance;
    }
}`,
      }, {
        internalFormat: scenePipeline.gl().RGBA16F,
      });

      const { render: debandingRender } = scenePipeline.add({
        fragmentShader: `
// This shader reduces color banding by adding controlled noise to smooth gradients

uniform sampler2D inputTexture;
uniform float noiseAmount;
uniform float ditherRange; // Range of colors to analyze for banding
uniform vec2 resolution;

in vec2 vUv;
out vec4 FragColor;

float random(vec2 coords) {
    return fract(sin(dot(coords.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main() {
    vec2 uv = vUv;

    // Sample the original color
    vec4 originalColor = texture(inputTexture, uv);

    // Generate controlled noise based on position
    // This helps break up banding patterns
    vec3 noise = vec3(
        random(uv + 0.07 * fract(vec2(1.0, 0.0))),
        random(uv + 0.07 * fract(vec2(0.0, 1.0))),
        random(uv + 0.07 * fract(vec2(1.0, 1.0)))
    );

    // Remap noise from [0,1] to [-0.5,0.5]
    noise = noise - 0.5;

    // Apply noise only to smooth gradients
    // First, sample neighboring pixels to detect gradients
    vec4 neighbors[4];
    neighbors[0] = texture(inputTexture, uv + vec2(1.0, 0.0) / resolution);
    neighbors[1] = texture(inputTexture, uv + vec2(-1.0, 0.0) / resolution);
    neighbors[2] = texture(inputTexture, uv + vec2(0.0, 1.0) / resolution);
    neighbors[3] = texture(inputTexture, uv + vec2(0.0, -1.0) / resolution);

    // Calculate color differences
    float colorDifference = 0.0;
    for (int i = 0; i < 4; i++) {
        colorDifference += distance(originalColor.rgb, neighbors[i].rgb);
    }
    colorDifference /= 4.0;

    // Apply more noise to areas with subtle gradient changes (where banding occurs)
    // and less noise to areas with sharp changes or flat colors
    float bandingDetection = 1.0 - smoothstep(0.0, ditherRange, colorDifference);

    // Apply the noise with intensity control
    vec3 finalColor = originalColor.rgb + noise * noiseAmount * bandingDetection;

    // Output the processed color
    FragColor = vec4(finalColor, originalColor.a);
}`,
        uniforms: {
          inputTexture: null,
          noiseAmount: 0.015,
          ditherRange: 1.0,
          resolution: [this.width, this.height],
        }
      });

      // Create a simple render pass that sets up the SDF scene
      const { render: drawRender, renderTargets: drawRenderTargets } = scenePipeline.add({
        fragmentShader: `
        uniform vec2 resolution;
        uniform float time;
        out vec4 FragColor;

        in vec2 vUv;

        // 3D Signed Distance Functions
        float sphereSDF(vec3 p, float radius) {
            return length(p) - radius;
        }

        float planeSDF(vec3 p, vec3 normal, float distance) {
            return dot(p, normal) + distance;
        }

        // Combine distance functions with min for union
        float sceneSDF(vec3 p) {
            // Two spheres and a plane
            float sphere1 = sphereSDF(p - vec3(0.0, 0.0, 0.0), 0.4);     // White sphere at origin
            float sphere2 = sphereSDF(p - vec3(0.8, 0.0, 0.4), 0.3);     // Black sphere offset
            float plane = planeSDF(p, vec3(0.0, 1.0, 0.0), 0.5);         // Plane below the spheres

            // return min(min(sphere1, sphere2), plane);
            return min(sphere1, sphere2);
        }

        // Return color based on object ID
        vec4 sceneColor(vec3 p) {
            float sphere1 = sphereSDF(p - vec3(0.0, 0.0, 0.0), 0.4);
            float sphere2 = sphereSDF(p - vec3(0.8, 0.0, 0.4), 0.3);
            float plane = planeSDF(p, vec3(0.0, 1.0, 0.0), 0.5);

            float minDist = min(min(sphere1, sphere2), plane);

            if (minDist == sphere1) return vec4(1.0, 1.0, 1.0, 1.0);      // White sphere
            if (minDist == sphere2) return vec4(0.0, 0.0, 0.0, 1.0);      // Black sphere
            if (minDist == plane) return vec4(0.8, 0.8, 0.8, 1.0);        // Gray plane

            return vec4(0.0);
        }

        // Camera setup
        vec3 getRayDirection(vec2 uv, vec3 camPos, vec3 lookAt, float zoom) {
            vec3 forward = normalize(lookAt - camPos);
            vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));
            vec3 up = cross(forward, right);

            // Convert uv from [0,1] to [-1,1] and adjust for aspect ratio
            vec2 screenPos = (uv * 2.0 - 1.0) * vec2(resolution.x / resolution.y, 1.0);

            return normalize(forward + right * screenPos.x / zoom + up * screenPos.y / zoom);
        }

        void main() {
            // Camera animation - circular flight path
            float camRadius = 2.0;
            float camHeight = 1.2;
            float camAngle = time * 0.5;

            vec3 camPos = vec3(
                camRadius * cos(camAngle),
                camHeight,
                camRadius * sin(camAngle)
            );

            vec3 lookAt = vec3(0.4, 0.0, 0.2); // Looking at center point between spheres
            float zoom = 1.5;

            vec3 rayDir = getRayDirection(vUv, camPos, lookAt, zoom);

            // Simple hit test for demo purposes - just set positions
            // Objects closer to the camera have higher priority
            vec3 testPositions[3];
            testPositions[0] = vec3(0.0, 0.0, 0.0);      // White sphere
            testPositions[1] = vec3(0.8, 0.0, 0.4);      // Black sphere
            testPositions[2] = vec3(0.0, -0.5, 0.0);     // Ground plane

            // Find closest hit
            vec3 hitPos = vec3(0.0);
            bool hit = false;

            for (int i = 0; i < 2; i++) {  // Only check the spheres for now
                vec3 objectPos = testPositions[i];
                float radius = (i == 0) ? 0.4 : 0.3;

                // Simplified ray-sphere intersection
                vec3 oc = camPos - objectPos;
                float a = dot(rayDir, rayDir);
                float b = 2.0 * dot(oc, rayDir);
                float c = dot(oc, oc) - radius * radius;
                float discriminant = b * b - 4.0 * a * c;

                if (discriminant > 0.0) {
                    float t = (-b - sqrt(discriminant)) / (2.0 * a);
                    if (t > 0.0) {
                        hitPos = camPos + rayDir * t;
                        hit = true;
                        break;
                    }
                }
            }

            if (hit) {
                // Output position for JFA
                FragColor = vec4(hitPos, 1.0);
            } else {
                // Background (sky)
                FragColor = vec4(vec3(0.0), 0.0);
            }
        }`,
        uniforms: {
          resolution,
          time: 0.0,
        }
      }, {
        internalFormat: scenePipeline.gl().RGBA32F,
        format: scenePipeline.gl().RGBA,
        type: scenePipeline.gl().FLOAT,
      });

      const drawPass = (time) => {
        drawRender({
          renderTarget: drawRenderTargets[0],
          uniforms: { time }
        });
        return drawRenderTargets[0].texture;
      }
      
      // Seed pass for JFA - just marks the seeds for jump flooding
      const seedPass = (sceneTexture) => {
        seedRender({
          renderTarget: seedRenderTargets[0],
          uniforms: { 
            surfaceTexture: sceneTexture
          }
        });
        return seedRenderTargets[0].texture;
      }

      const jfaPass = (seedTexture) => {
        let currentInput = seedTexture;

        let [renderA, renderB] = jfaRenderTargets;
        let currentOutput = renderA;
        let passes = jfaUniforms.passes;

        // First in X direction
        for (let i = 0; i < passes || (passes === 0 && i === 0); i++) {
          const offset = Math.pow(2, passes - i);

          jfaRender({
            renderTarget: currentOutput,
            uniforms: {
              skip: passes === 0,
              inputTexture: currentInput,
              uOffset: offset,
              direction: 0,
            },
          });

          currentInput = currentOutput.texture;
          currentOutput = (currentOutput === renderA) ? renderB : renderA;
        }

        // Then in Y direction
        for (let i = 0; i < passes || (passes === 0 && i === 0); i++) {
          const offset = Math.pow(2, passes - i);

          jfaRender({
            renderTarget: currentOutput,
            uniforms: {
              skip: passes === 0,
              inputTexture: currentInput,
              uOffset: offset,
              direction: 1,
            },
          });

          currentInput = currentOutput.texture;
          currentOutput = (currentOutput === renderA) ? renderB : renderA;
        }

        // Finally in Z direction (conceptual)
        for (let i = 0; i < passes || (passes === 0 && i === 0); i++) {
          const offset = Math.pow(2, passes - i);

          jfaRender({
            renderTarget: currentOutput,
            uniforms: {
              skip: passes === 0,
              inputTexture: currentInput,
              uOffset: offset,
              direction: 2,
            },
          });

          currentInput = currentOutput.texture;
          currentOutput = (currentOutput === renderA) ? renderB : renderA;
        }

        return currentInput;
      }

      const dfPass = (jfaTexture) => {
        dfRender({
          renderTarget: dfRenderTargets[0],
          uniforms: {
            jfaTexture,
          }
        });
        return dfRenderTargets[0].texture;
      }

      const giPass = (sceneTexture, distanceTexture, previewAction) => {
        giRender({
          renderTarget: giRenderTargets[0],
          uniforms: {
            distanceTexture,
            sceneTexture,
            rayCount: previewAction ? 8 : 128
          }
        });
        return giRenderTargets[0].texture;
      }

      const sceneLayer = new Layer(
        'scene-layer',
        scenePipeline,
        (_, progress, previewAction) => {
          // First draw the scene with the SDF setup (no raymarching)
          const sceneTexture = drawPass(progress);
          drawRender();

          // // Then seed the JFA with the scene data
          // const seedTexture = seedPass(sceneTexture);
          // // Run the JFA
          // const jfaTexture = jfaPass(seedTexture);
          // // Calculate the distance field
          // const distanceTexture = dfPass(jfaTexture);
          // // Apply global illumination
          // const giTexture = giPass(sceneTexture, distanceTexture, previewAction);
          //
          // debandingRender({
          //   uniforms: {
          //     inputTexture: giTexture,
          //   }
          // });
        },
        {
          ignorePanZoom: true,
          renderDuringPreviewAction: true,
          extras: {
            uniforms: sceneUniforms,
          },
        });

      this.pushLayer(sceneLayer);
    }
    *animationSequence() {
      const { width, height } = this.canvas;

      // Show layers with orbiting camera
      this.animate([
        {
          layer: ['scene-layer'],
          draw(_, progress, { layers }) {
            if (layers['scene-layer'].extras) {
              layers['scene-layer'].extras.uniforms.sunAngle = progress * Math.PI * 2.0;
            }
          }
        },
      ], { duration: 10.0, easing: Easing.easeInOutCubic, delay: 0.0 });
    }
  }

  document.addEventListener('DOMContentLoaded', async () => {
    const app = document.querySelector("#preview");
    if (!app) return;

    // Create canvas
    const canvas = document.createElement("canvas");

    const isMobile = (() => {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
        || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    })();

    const dpr = window.devicePixelRatio || 1;
    const windowWidth = window.innerWidth * dpr;
    const ratio = isMobile ? windowWidth / 1920 : 1;

    let width = 1920 * ratio;
    let height = 1080 * ratio;

    canvas.width = width;
    canvas.height = height;
    app.append(canvas);

    // Create Mation instance
    const mation = new Mation();

    const scene = new My3DScene({canvas, width, height});

    // Set the scene on the Mation instance
    mation.setScene(scene);

    // Initialize Mation (this will create UI controls and start the animation)
    await mation.initialize(app);
  });
</script>
</body>
</html>